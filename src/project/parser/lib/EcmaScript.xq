xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sun May 1, 2016 20:07 (UTC+02) by REx v5.39 which is Copyright (c) 1979-2016 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: EcmaScript.ebnf -xquery -asi -ll 1 -backtrack -tree :)

(:~
 : The parser that was generated for the EcmaScript grammar.
 :)
module namespace p="EcmaScript";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 7;

(:~
 : The index of the parser state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo as xs:integer := 8;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 9;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  66, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 23, 24, 25, 26, 27, 28, 29, 30, 30, 30,
  30, 31, 30, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 32, 8, 8, 33, 34, 35, 36, 8, 29, 37, 38, 39, 40, 41,
  42, 43, 44, 45, 8, 46, 47, 48, 49, 50, 51, 8, 52, 53, 54, 55, 56, 57, 58, 59, 8, 60, 61, 62, 63, 29
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 335, 247, 367, 432, 695, 303, 400, 400, 464, 496, 528, 560, 592, 640, 669, 899, 727, 400, 400, 400, 400, 608,
  400, 398, 400, 400, 400, 400, 400, 759, 791, 823, 275, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 855, 887, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 943, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 975, 1007, 1016, 1008, 1008, 1024, 1032, 1040, 1048, 1056, 1315, 1315, 1075,
  1096, 1104, 1112, 1120, 1199, 1196, 1196, 1196, 1137, 1196, 1346, 1196, 1315, 1315, 1316, 1315, 1315, 1315, 1316,
  1315, 1315, 1315, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315,
  1315, 1315, 1195, 1196, 1450, 1194, 1196, 1397, 1196, 1196, 1196, 1196, 1196, 1139, 1495, 1196, 1196, 1196, 1196,
  1196, 1196, 1196, 1196, 1196, 1196, 1193, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196,
  1196, 1196, 1196, 1314, 1315, 1315, 1193, 1412, 1066, 1396, 1196, 1391, 1397, 1412, 1315, 1315, 1315, 1315, 1315,
  1315, 1315, 1315, 1451, 1315, 1316, 1207, 1391, 1372, 1270, 1391, 1397, 1315, 1315, 1315, 1315, 1315, 1315, 1311,
  1316, 1314, 1298, 1315, 1315, 1315, 1315, 1315, 1316, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1460, 1448,
  1315, 1315, 1315, 1315, 1257, 1313, 1391, 1391, 1391, 1391, 1391, 1391, 1391, 1391, 1393, 1196, 1196, 1196, 1397,
  1196, 1196, 1196, 1173, 1517, 1315, 1315, 1297, 1315, 1315, 1315, 1315, 1316, 1316, 1426, 1298, 1315, 1460, 1196,
  1198, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196,
  1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1314, 1318, 1315, 1315, 1315,
  1315, 1315, 1315, 1315, 1315, 1314, 1318, 1315, 1315, 1315, 1315, 1147, 1196, 1315, 1315, 1315, 1315, 1315, 1315,
  1415, 1160, 1315, 1315, 1315, 1416, 1414, 1194, 1528, 1315, 1315, 1315, 1315, 1315, 1315, 1223, 1391, 1393, 1271,
  1315, 1241, 1391, 1196, 1196, 1528, 1415, 1312, 1315, 1315, 1298, 1255, 1266, 1184, 1244, 1346, 1281, 1241, 1391,
  1194, 1196, 1291, 1461, 1312, 1315, 1315, 1298, 1306, 1266, 1247, 1244, 1196, 1515, 1347, 1391, 1213, 1196, 1528,
  1516, 1297, 1315, 1315, 1298, 1501, 1223, 1327, 1152, 1196, 1196, 1336, 1391, 1196, 1196, 1528, 1415, 1312, 1315,
  1315, 1298, 1309, 1223, 1272, 1244, 1347, 1281, 1163, 1391, 1196, 1196, 1487, 1215, 1360, 1356, 1258, 1215, 1317,
  1163, 1273, 1270, 1346, 1196, 1346, 1391, 1196, 1196, 1528, 1318, 1298, 1315, 1315, 1298, 1319, 1163, 1328, 1270,
  1348, 1196, 1163, 1391, 1196, 1196, 1487, 1318, 1298, 1315, 1315, 1298, 1319, 1163, 1328, 1270, 1348, 1139, 1163,
  1391, 1196, 1196, 1487, 1318, 1298, 1315, 1315, 1298, 1315, 1163, 1185, 1270, 1346, 1196, 1163, 1391, 1196, 1196,
  1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1137, 1196, 1196,
  1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1314, 1315, 1315, 1315, 1315, 1316,
  1368, 1396, 1063, 1392, 1391, 1397, 1196, 1196, 1196, 1196, 1436, 1086, 1449, 1314, 1127, 1283, 1368, 1233, 1380,
  1393, 1391, 1397, 1196, 1196, 1196, 1196, 1397, 1391, 1397, 1405, 1385, 1315, 1314, 1315, 1315, 1315, 1194, 1390,
  1391, 1328, 1395, 1327, 1390, 1391, 1393, 1390, 1344, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1314, 1315,
  1315, 1315, 1316, 1171, 1314, 1315, 1315, 1315, 1316, 1196, 1390, 1391, 1181, 1391, 1391, 1229, 1341, 1196, 1315,
  1315, 1315, 1193, 1193, 1196, 1501, 1500, 1193, 1196, 1196, 1196, 1196, 1424, 1195, 1424, 1257, 1446, 1129, 1256,
  1435, 1196, 1196, 1196, 1196, 1139, 1196, 1088, 1138, 1358, 1193, 1196, 1196, 1196, 1196, 1444, 1195, 1171, 1315,
  1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1460,
  1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1194, 1315, 1315, 1414, 1414, 1315, 1315, 1315,
  1315, 1414, 1414, 1315, 1427, 1315, 1315, 1315, 1414, 1315, 1315, 1315, 1315, 1315, 1315, 1318, 1082, 1294, 1459,
  1416, 1460, 1315, 1459, 1294, 1459, 1476, 1481, 1196, 1196, 1196, 1469, 1196, 1196, 1196, 1196, 1196, 1197, 1196,
  1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1391, 1394, 1344, 1196, 1196, 1196,
  1509, 1196, 1196, 1196, 1314, 1067, 1183, 1196, 1314, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1459,
  1484, 1314, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1525, 1448, 1315, 1315, 1315, 1315, 1459,
  1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196,
  1196, 1196, 1196, 1196, 1196, 1196, 1196, 1315, 1315, 1315, 1315, 1414, 1196, 1315, 1315, 1315, 1315, 1316, 1196,
  1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315,
  1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1414, 1196, 1196, 1196, 1196, 1196,
  1196, 1196, 1196, 1196, 1196, 1196, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315, 1315,
  1315, 1315, 1315, 1315, 1315, 1315, 1315, 1460, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 1196, 66,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 4, 0, 0, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 21,
  21, 21, 21, 21, 21, 22, 22, 23, 24, 25, 26, 27, 28, 29, 30, 30, 30, 30, 31, 30, 8, 8, 8, 8, 8, 8, 64, 64, 64, 64, 64,
  64, 32, 8, 8, 33, 34, 35, 36, 8, 8, 8, 8, 8, 29, 8, 29, 29, 8, 29, 29, 8, 8, 29, 37, 38, 39, 40, 41, 42, 43, 44, 45,
  8, 46, 47, 48, 49, 50, 51, 8, 52, 53, 54, 55, 56, 57, 58, 59, 8, 60, 61, 62, 63, 29, 8, 8, 8, 29, 8, 29, 8, 29, 8, 1,
  29, 29, 29, 29, 29, 29, 29, 8, 29, 8, 8, 29, 64, 64, 64, 64, 29, 64, 64, 64, 29, 29, 8, 29, 29, 8, 8, 29, 29, 29, 29,
  64, 64, 29, 8, 29, 29, 29, 29, 29, 29, 8, 64, 64, 64, 29, 64, 64, 64, 64, 64, 29, 29, 64, 64, 8, 8, 8, 29, 29, 29, 29,
  29, 29, 29, 29, 1, 29, 29, 8, 8, 8, 8, 29, 8, 64, 64, 8, 8, 8, 29, 29, 29, 8, 8, 8, 8, 29, 29, 64, 8, 64, 64, 29, 64,
  64, 64, 29, 64, 64, 8, 29, 29, 8, 8, 64, 64, 29, 29, 64, 64, 64, 29, 29, 29, 29, 64, 8, 29, 8, 29, 29, 29, 8, 8, 29,
  29, 29, 8, 8, 29, 29, 64, 29, 64, 64, 64, 64, 29, 29, 29, 64, 64, 29, 29, 29, 29, 8, 8, 29, 8, 8, 29, 29, 29, 64, 29,
  29, 8, 8, 8, 29, 8, 8, 8, 8, 8, 8, 8, 29, 8, 8, 29, 8, 8, 29, 29, 8, 8, 8, 8, 8, 8, 8, 8, 29, 8, 8, 8, 64, 64, 64, 64,
  64, 64, 29, 64, 64, 8, 29, 29, 29, 29, 29, 64, 64, 29, 64, 29, 29, 29, 29, 29, 29, 29, 64, 64, 29, 29, 8, 8, 29, 8,
  29, 8, 8, 8, 8, 29, 29, 8, 64, 8, 8, 64, 64, 64, 64, 64, 8, 8, 64, 8, 8, 8, 8, 8, 29, 64, 29, 29, 29, 29, 64, 64, 64,
  64, 64, 64, 64, 64, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 64, 29, 64, 8, 8, 8, 8, 8, 8, 8, 29, 29, 8, 8, 29, 29,
  29, 29, 8, 29, 8, 29, 8, 29, 8, 29, 29, 8, 8, 29, 8, 29, 29, 8, 29, 29, 29, 8, 29, 29, 29, 29, 29, 8, 8, 8, 8, 8, 29,
  8, 8, 8, 8, 8, 29, 29, 29, 29, 8, 65, 65, 29, 29, 29, 29, 29, 1, 1, 1, 1, 1, 1, 1, 1, 29, 64, 64, 29, 29, 64, 64, 29,
  8, 8, 8, 29, 29, 8, 8, 29, 29, 8, 29, 8, 8, 29, 8, 8, 8, 1, 29, 29, 29, 29, 64, 29, 8, 8, 8, 8, 29, 8, 29, 8, 8, 8, 8,
  8, 29, 64, 64, 64, 29, 8, 8, 8
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65279, 65280, 65536, 65278, 65279, 65533, 1114111, 29, 1, 29, 29
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1040, 17, 1042, 1043, 20, 21, 22, 23, 24, 25, 26, 1051, 1052, 29,
  30, 31, 32, 33, 34, 35, 36, 1061
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 4288, 4288, 4288, 4288, 4298, 4432, 6773, 4312, 4325, 4563, 6640, 4433,
  6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445,
  4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 4288, 4288, 4288, 4288, 4298,
  4432, 6773, 4312, 6639, 4563, 6640, 4433, 6774, 6061, 4443, 4433, 4418, 6775, 4339, 6639, 4433, 4352, 4370, 5084,
  4432, 4418, 4418, 4625, 4393, 4483, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362,
  4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 4288, 4288, 4288, 4288, 4290, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 4288, 4288, 4288, 4288, 4298, 4432, 6773, 4312, 6639, 4563,
  6640, 4433, 6774, 6061, 4443, 4433, 4418, 6775, 4503, 6639, 4433, 4352, 4370, 5084, 4432, 4418, 4418, 4625, 6786,
  4483, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6704,
  4522, 4526, 4432, 6773, 4312, 4325, 4563, 6640, 4419, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352,
  4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016,
  4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 5606, 4534, 5610, 4432, 6773, 4312, 4549, 4563, 6640, 4433, 6774, 6257, 4443,
  4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4636, 5184, 4445, 4412, 4560, 4418,
  4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6787, 5035, 4432, 6773, 4312,
  4325, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418,
  4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785,
  5564, 5698, 6469, 4602, 6472, 6107, 4574, 5280, 6048, 5836, 6473, 6108, 6257, 6472, 4840, 4840, 6109, 6299, 6497,
  6473, 4399, 4840, 4585, 6472, 4840, 4840, 5936, 4393, 4593, 6468, 4840, 6045, 4840, 6109, 5835, 6467, 4840, 6470,
  6108, 7316, 4840, 7061, 6471, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5579, 5519, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774,
  6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412,
  4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5668, 7124, 4432,
  6773, 4312, 4325, 7387, 6640, 4433, 7166, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432,
  4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453,
  4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 5850, 4610, 5854, 4432, 6773, 4312, 4618, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775,
  4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4633, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427,
  4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 4644, 4645, 6217, 4654, 4658, 4432, 6773, 4312, 4325, 4563, 6640,
  4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184,
  4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5783, 4666, 5193, 5782,
  5217, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370,
  4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555,
  4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 5909, 6552, 4432, 6773, 4312, 4344, 4563, 6640, 4433, 6774, 4385, 4443, 4433,
  4418, 6775, 4339, 6761, 4433, 4352, 4370, 4677, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566,
  7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6809, 4685, 4689, 4432, 6773, 4312, 4325,
  4359, 6640, 4433, 5048, 6257, 4443, 4433, 4418, 6775, 4339, 4697, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625,
  4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 4705,
  4722, 4721, 6616, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433,
  4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489,
  5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6903, 4730, 4734, 4432, 6773, 4312, 4325, 7382, 6640, 4433, 6774, 4742,
  4443, 4433, 4418, 6775, 4339, 4697, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560,
  4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6075, 4750, 6079, 4432, 6773,
  4312, 4758, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418,
  4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467,
  4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  4766, 4766, 4769, 4777, 4781, 4432, 6773, 4312, 4789, 4563, 6640, 4433, 6774, 4797, 4443, 4433, 4418, 6775, 4339,
  7234, 4433, 4352, 4370, 4805, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459,
  4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 7300, 4813, 7304, 6472, 6107, 4574, 4821, 6048, 5836, 6473,
  6108, 6257, 4839, 4840, 4840, 6350, 6231, 4850, 6473, 4399, 4840, 4585, 4874, 4840, 4840, 6374, 4884, 4892, 6468,
  4840, 6572, 4840, 6051, 4903, 6467, 4840, 4840, 5894, 4916, 4840, 5703, 6471, 4936, 4947, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 4510, 4965, 4514,
  6472, 6107, 4574, 4821, 6048, 5836, 6473, 6108, 6257, 4839, 4840, 4840, 6350, 6231, 4850, 6473, 4399, 4840, 4585,
  4874, 4840, 4840, 6374, 4884, 4892, 6468, 4840, 6572, 4840, 6051, 4903, 6467, 4840, 4840, 5894, 4916, 4840, 5703,
  6471, 4936, 4947, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 4510, 4965, 4514, 6472, 6107, 4574, 6236, 6048, 5836, 6473, 6108, 6257, 4839, 4840, 4840,
  6350, 4577, 4973, 6473, 4399, 4840, 4585, 4874, 4840, 4840, 6374, 4884, 4892, 6468, 4840, 6572, 4840, 6051, 4903,
  6467, 4840, 4840, 5894, 4916, 4840, 5703, 6471, 4936, 4947, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6167, 6786, 6786, 6167, 4831, 4432, 6773, 4312, 4325, 4563,
  6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393,
  5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5592, 4991,
  5002, 5005, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352,
  4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016,
  4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6314, 7090, 4432, 6773, 4312, 4325, 4563, 5013, 4433, 6774, 5024, 4443,
  4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418,
  4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5032, 6213, 5337, 4432, 6773, 4312,
  4325, 4304, 5043, 4433, 4331, 5056, 4443, 4433, 4418, 6775, 4339, 6761, 4371, 5064, 4370, 5072, 4432, 4418, 4418,
  4625, 4393, 5184, 4445, 4412, 6767, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6662, 7340, 4432, 6773, 4312, 4325, 4563, 5080, 4433, 6774, 7286, 4443, 4433, 4418, 6775, 4339, 6761,
  4433, 5092, 4370, 5100, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441,
  4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 7431, 4317, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774,
  6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412,
  4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5035, 4432,
  6773, 4312, 4325, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432,
  4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453,
  4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6785, 5564, 5698, 6469, 4602, 6472, 6107, 4574, 5280, 6048, 5836, 6473, 6108, 6257, 4839, 4840, 4840, 6350,
  6299, 5108, 6473, 4399, 4840, 4585, 4874, 4840, 4840, 6374, 4884, 4593, 6468, 4840, 6572, 4840, 6051, 4903, 6467,
  4840, 4840, 5894, 4916, 4840, 5703, 6471, 4936, 4947, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469, 4602, 6472, 6107, 4574, 5122, 6048, 5836,
  6473, 6108, 6257, 4839, 4840, 4840, 6350, 7049, 5108, 6473, 4399, 4840, 4585, 4874, 4840, 4840, 6374, 4884, 4593,
  6468, 4840, 6572, 4840, 6051, 4903, 6467, 4840, 4840, 5894, 4916, 4840, 5703, 6471, 4936, 4947, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469,
  4602, 6472, 6107, 4574, 5152, 6048, 5836, 6473, 6108, 6257, 6472, 4840, 4840, 6109, 6299, 6497, 6473, 4399, 4840,
  4585, 6472, 4840, 4840, 5936, 4393, 4593, 6468, 4840, 6045, 4840, 6109, 5835, 6467, 4840, 6470, 6108, 7316, 4840,
  7061, 6471, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6666, 5169, 5173, 4432, 6773, 4312, 5181, 4563, 6640, 4433, 6774, 6257, 4443, 4433,
  4418, 6775, 4339, 6823, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566,
  7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5192, 5201, 5225, 5230, 5234, 6927, 5351, 5242, 5255,
  5264, 5462, 6928, 5352, 6257, 5403, 5305, 5304, 5353, 5275, 6917, 6928, 5288, 5303, 5313, 6927, 5304, 5304, 5295,
  5321, 5345, 6923, 5361, 5261, 5304, 5267, 5583, 5375, 5367, 5401, 5381, 5465, 5417, 5422, 5411, 5430, 5438, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 5446, 5247, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6271, 4433,
  4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489,
  5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5458, 5736, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774, 6257,
  4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560,
  4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469, 4602, 5917, 6403,
  5473, 6984, 5507, 5913, 5496, 5515, 6257, 5527, 4840, 4840, 6350, 6299, 5108, 6473, 4399, 4840, 4585, 5539, 6457,
  4840, 5488, 5547, 4593, 6507, 4840, 5555, 4840, 5572, 4903, 5161, 4840, 4840, 5894, 4916, 4840, 5703, 6471, 4936,
  4947, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  5591, 5600, 5618, 5623, 5627, 6472, 6107, 4574, 5280, 6048, 5836, 6473, 6108, 6257, 5635, 4840, 4840, 6350, 6299,
  5108, 5636, 5387, 4840, 5644, 4874, 4840, 4840, 6374, 4884, 4593, 6468, 4840, 6572, 4840, 6051, 4903, 6467, 4840,
  4840, 5894, 4916, 4840, 5703, 6471, 4936, 4947, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 5652, 5661, 5680, 5685, 5693, 6472, 6107, 4574, 5280, 6048, 5836, 6473,
  6108, 6257, 4839, 4840, 4840, 6350, 6299, 5108, 6473, 4399, 4840, 4585, 5711, 5747, 4840, 4957, 4884, 5726, 6468,
  4840, 6572, 4840, 6051, 4903, 6467, 5744, 4840, 5894, 4916, 4840, 5144, 5755, 4936, 4947, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5765, 5775, 5791, 5797, 5805,
  6472, 6107, 4574, 5280, 6048, 5836, 6473, 6108, 6257, 4839, 4840, 4840, 6350, 6299, 5108, 6473, 4399, 4840, 4585,
  4874, 4840, 4842, 6374, 4884, 4593, 4862, 4840, 6572, 4840, 6051, 4903, 6467, 4840, 5757, 5894, 4916, 4840, 5703,
  6471, 4936, 4947, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 5833, 5844, 5862, 5867, 5875, 6363, 5893, 5902, 5925, 4952, 5672, 6042, 5933, 6257, 5944, 4840, 4840,
  6350, 7049, 5108, 6473, 7180, 4840, 4585, 5954, 5965, 6584, 6374, 5977, 4593, 5985, 4840, 5997, 4840, 5114, 4903,
  6467, 7073, 4840, 5894, 6014, 4840, 5703, 5881, 6036, 4947, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6059, 6069, 6087, 6092, 6097, 4401, 6107, 4574, 5280, 6048,
  5836, 6105, 6108, 6257, 6117, 4840, 4840, 6350, 6126, 5108, 6118, 5207, 4840, 6139, 4874, 4840, 4840, 6374, 4884,
  4593, 6468, 4840, 6572, 4840, 6051, 4903, 6467, 4840, 4840, 5825, 6147, 4840, 5703, 6471, 4936, 6160, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785, 6006, 5810,
  6469, 4602, 6472, 6107, 4574, 5280, 6048, 5836, 6473, 6108, 6257, 6472, 4840, 4840, 6109, 6299, 6497, 6473, 4399,
  4840, 4585, 6472, 4840, 4840, 5936, 4393, 4593, 6468, 4840, 6045, 6179, 6109, 5835, 6467, 6189, 6398, 6108, 7316,
  6198, 7061, 6471, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469, 4602, 6472, 5393, 4574, 5280, 6207, 5836, 6799, 6108, 6257, 6472,
  4840, 4840, 6109, 6299, 6497, 6473, 4399, 4840, 4585, 6472, 4840, 4840, 6225, 4393, 4593, 6468, 6190, 6045, 4840,
  5731, 5835, 6467, 4840, 6470, 6108, 7316, 6244, 7061, 6471, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6255, 6265, 6279, 6284, 6288, 7148, 4983, 6296,
  6131, 6048, 5836, 6307, 7120, 6257, 6472, 4840, 6028, 6326, 6299, 6497, 6655, 4399, 6681, 4585, 6472, 4840, 4840,
  5936, 4393, 4593, 6468, 4840, 6045, 6339, 6109, 5835, 4928, 4840, 6470, 6349, 6358, 4840, 7061, 6471, 7365, 5502,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785,
  5564, 5698, 6469, 4602, 6472, 6107, 4574, 5280, 6048, 5836, 6473, 6108, 6257, 6472, 4840, 4840, 6109, 6299, 6497,
  6473, 4399, 4840, 4585, 6472, 4840, 4840, 5936, 4393, 4593, 6468, 4840, 5715, 4840, 6109, 5835, 7271, 4840, 6470,
  6108, 7316, 4840, 7061, 6471, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469, 4602, 4713, 6107, 4574, 5280, 6048, 4709, 6473, 6371,
  6257, 7220, 5158, 6382, 6109, 6299, 6718, 6393, 5327, 4840, 6411, 6472, 4841, 4875, 6688, 4393, 6419, 6468, 6181,
  6045, 6341, 7107, 5835, 6467, 4840, 6439, 7184, 6447, 6385, 7061, 6471, 7365, 5502, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469, 4602, 4866,
  6107, 4574, 5280, 6048, 5836, 6465, 6108, 6257, 6472, 4840, 4840, 6109, 6299, 6497, 6473, 4399, 4840, 4585, 6472,
  5955, 4840, 5936, 4393, 4593, 6468, 4840, 6045, 4840, 6109, 5835, 6467, 4840, 6470, 6108, 7316, 4840, 7061, 6471,
  7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6481, 6491, 6515, 6520, 6524, 4921, 6107, 6532, 5280, 6048, 7144, 4926, 5213, 6257, 6019, 6431, 4840, 7261,
  6299, 6604, 6473, 5479, 4840, 6540, 6472, 4840, 4840, 5936, 4393, 4593, 6468, 4840, 6045, 6247, 6109, 5835, 6467,
  4840, 6503, 6548, 6560, 6568, 7061, 6471, 7216, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469, 4602, 6580, 5484, 4574, 6865, 5718, 6171,
  6592, 6612, 6257, 6472, 4840, 4840, 6109, 6299, 6497, 6473, 4399, 4840, 4585, 6472, 6624, 6628, 5936, 4393, 4593,
  6468, 4979, 6045, 4840, 6636, 5835, 5128, 4840, 6470, 6108, 7316, 4840, 6648, 6471, 7365, 6598, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469,
  4602, 6472, 6107, 4574, 5280, 6048, 5836, 6473, 6108, 6257, 6472, 6674, 5139, 6109, 6299, 6497, 4895, 4399, 4840,
  4585, 6472, 4840, 4840, 5936, 4393, 4593, 6468, 4840, 6045, 4840, 6109, 5835, 6467, 4840, 6470, 6108, 7316, 4840,
  7061, 6471, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6702, 6712, 6726, 6731, 6735, 6743, 5561, 4574, 5280, 6755, 6318, 6877, 6108, 6257, 6472, 4403,
  4596, 4827, 6299, 6497, 4599, 4495, 4856, 4585, 6472, 4840, 4840, 5936, 4393, 4593, 6468, 4840, 6045, 7030, 6783,
  5835, 6467, 6795, 6470, 6108, 7316, 4840, 7061, 6471, 7448, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6807, 6817, 6831, 6836, 6840, 6472, 6107, 4574, 5280,
  6048, 5836, 6473, 6108, 6257, 6848, 5957, 4840, 6109, 6860, 6497, 6473, 6873, 4840, 6885, 6152, 4840, 6024, 5936,
  4393, 6893, 5885, 4840, 6045, 4840, 6109, 5835, 6467, 4840, 6470, 6108, 7316, 4840, 7061, 6471, 7365, 5502, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6901, 6911,
  6936, 6942, 6946, 6472, 6107, 4574, 5280, 6048, 5836, 6473, 6108, 6257, 6954, 6967, 7026, 7138, 6979, 6497, 6473,
  4399, 6992, 7000, 4908, 5946, 6453, 5936, 4393, 4593, 7012, 7008, 5531, 6852, 6109, 6483, 7020, 4840, 6470, 6108,
  7316, 4840, 5815, 4939, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469, 4602, 7038, 7059, 7046, 4541, 6048, 5836, 7057, 7086, 6257,
  6472, 7069, 4876, 6109, 6694, 6497, 6959, 4399, 6958, 4585, 5989, 4840, 7081, 5936, 4393, 4593, 5969, 7098, 6045,
  7115, 6109, 7132, 6467, 6199, 6470, 6108, 7316, 4875, 7061, 6426, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 7156, 7174, 7192, 7198, 7202, 6472, 6107,
  4574, 5280, 6048, 5836, 6473, 6108, 6257, 6472, 4840, 4840, 6109, 6299, 6497, 6473, 4399, 4840, 4585, 6472, 4840,
  4840, 5936, 4393, 4593, 6468, 4840, 6045, 4840, 6109, 5835, 6467, 4840, 6470, 6108, 7316, 4840, 7061, 6471, 7365,
  5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  7210, 7228, 7242, 7247, 7251, 6472, 7259, 4574, 5280, 6048, 5836, 7103, 6108, 6257, 6472, 4840, 5956, 6109, 6299,
  6497, 7269, 4399, 4840, 4585, 6472, 4840, 4840, 5936, 4393, 4593, 6468, 4840, 6045, 4840, 6109, 5835, 6467, 5134,
  6470, 6108, 7316, 4840, 7061, 6471, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469, 4602, 5820, 6107, 4574, 5152, 6048, 5836, 6473,
  5333, 6257, 6472, 4840, 4840, 6109, 7279, 6497, 6473, 4399, 4840, 4585, 6472, 4840, 4840, 5936, 4393, 4593, 6468,
  4840, 6045, 4840, 6109, 5835, 6467, 4840, 6470, 6108, 7316, 4840, 7061, 6471, 7365, 5502, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6785, 5564, 5698, 6469, 4602,
  6472, 6003, 4574, 5280, 7294, 5836, 6747, 6108, 6257, 6472, 4840, 4842, 6109, 6299, 6497, 4404, 4399, 6971, 4585,
  6472, 4840, 4840, 5936, 4393, 4593, 6468, 4840, 6045, 4840, 6109, 5835, 6467, 4840, 6470, 6108, 7316, 4840, 7312,
  7368, 7365, 5502, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 4669, 6786, 7435, 7324, 7328, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418,
  6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416,
  4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 7336, 6331, 4432, 6773, 4312, 4325, 4563,
  7161, 4433, 6774, 5450, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393,
  5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5653, 7348, 7360,
  7352, 7376, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774, 6257, 4443, 4433, 4418, 6775, 4339, 6761, 4433, 4352,
  4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016,
  4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 4994, 7395, 7399, 4432, 6773, 4312, 4325, 4563, 6640, 4433, 6774, 6257, 4443,
  4433, 4418, 6775, 4339, 6761, 4433, 4352, 4370, 4379, 4432, 4418, 4418, 4625, 4393, 5184, 4445, 4412, 4560, 4418,
  4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 5767, 6472, 6107, 4574,
  5280, 6048, 5836, 6473, 6108, 6257, 6472, 4840, 4840, 6109, 6299, 6497, 6473, 4399, 4840, 4585, 6472, 4840, 4840,
  5936, 4393, 4593, 6468, 4840, 6045, 4840, 6109, 5835, 6467, 4840, 6470, 6108, 7316, 4840, 7061, 6471, 7365, 5502,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 4288,
  4288, 4288, 4288, 4298, 4432, 6773, 4312, 6639, 4563, 6640, 4433, 6774, 6061, 4443, 4433, 4418, 6775, 4339, 6639,
  4433, 4352, 4370, 5084, 4432, 4418, 4418, 4625, 6786, 4483, 4445, 4412, 4560, 4418, 4566, 7416, 4427, 4459, 4441,
  4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 4646, 7413, 7407, 7424, 4432, 6773, 4312, 6639, 4563, 6640, 4433, 6774,
  6786, 4443, 4433, 4418, 6775, 7443, 6639, 4433, 4352, 4370, 5047, 4432, 4418, 4418, 4625, 6786, 4483, 4445, 4412,
  4560, 4418, 4566, 7416, 4427, 4459, 4441, 4489, 5016, 4555, 4362, 4453, 4467, 4475, 6786, 6786, 6786, 6786, 6786,
  6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 6786, 7206, 7206, 7206, 7206, 7206, 7206,
  7206, 7206, 0, 0, 7206, 7206, 7206, 7206, 7206, 7206, 68096, 0, 0, 68096, 68096, 68096, 8872, 0, 0, 69632, 0, 69632,
  69632, 0, 0, 0, 0, 27136, 0, 68096, 0, 65, 66, 0, 0, 0, 156, 68096, 68096, 68096, 68096, 10240, 11776, 13824, 15360,
  69632, 69632, 0, 0, 102400, 65, 66, 0, 0, 0, 111, 68096, 68096, 0, 0, 102400, 68096, 68096, 68096, 98816, 68096,
  14848, 0, 68096, 68096, 68096, 0, 0, 0, 68096, 98304, 101888, 68096, 68096, 68096, 68096, 68096, 68096, 68096, 9216,
  1721, 68096, 68096, 68096, 68096, 0, 0, 111, 0, 0, 0, 0, 192, 7792, 0, 0, 65, 0, 0, 66, 0, 0, 0, 39, 39, 39, 39, 39,
  119, 39, 39, 39, 0, 100352, 68096, 68096, 68096, 106496, 107520, 68096, 68096, 68096, 68096, 68096, 68096, 68096,
  68096, 1721, 105472, 69120, 68096, 68096, 108032, 0, 68096, 68096, 68096, 68096, 68096, 68096, 68096, 0, 99328, 68096,
  0, 68096, 68096, 68096, 68096, 68096, 0, 68096, 68096, 68096, 107008, 0, 68096, 68096, 103936, 104960, 68096, 68096,
  68096, 68096, 68096, 109056, 95744, 68096, 99840, 97792, 0, 68096, 0, 68096, 68096, 97792, 99840, 0, 100864, 0, 96768,
  97280, 0, 102912, 0, 0, 0, 68096, 68096, 103424, 68096, 68096, 68096, 68096, 108544, 96256, 0, 0, 0, 39, 39, 39, 39,
  249, 69632, 69632, 0, 0, 102400, 227, 230, 0, 0, 0, 5701, 5701, 5701, 5701, 5701, 0, 0, 39, 0, 8192, 8192, 8192, 79,
  8192, 8192, 8192, 8192, 79, 0, 68096, 0, 65, 65, 65, 0, 65, 65, 65, 65, 66, 0, 0, 0, 156, 160, 162, 4608, 66, 0, 0, 0,
  156, 68096, 68096, 68096, 105984, 108544, 68096, 68096, 68096, 68096, 0, 0, 68096, 68096, 68096, 0, 0, 0, 0, 95744, 0,
  58, 0, 58, 58, 0, 0, 0, 0, 0, 5784, 1721, 39, 39, 39, 39, 0, 0, 111, 0, 5354, 157, 39, 39, 39, 39, 39, 213, 39, 39,
  39, 39, 0, 0, 39, 0, 66, 66, 66, 0, 66, 66, 66, 66, 65, 4608, 0, 0, 0, 156, 68096, 68096, 107520, 0, 0, 0, 0, 101376,
  104448, 0, 0, 65, 0, 0, 4608, 0, 0, 66, 0, 0, 0, 12288, 0, 0, 0, 0, 0, 0, 0, 2048, 12288, 12288, 12288, 0, 12288,
  12288, 12288, 12288, 12288, 0, 68096, 0, 0, 12800, 12800, 0, 0, 0, 0, 0, 0, 44032, 0, 1721, 68096, 68096, 68096,
  68096, 0, 0, 192, 14410, 14410, 14410, 14336, 14410, 14410, 14410, 14410, 14440, 0, 68096, 0, 0, 233, 0, 156, 157,
  156, 68096, 68096, 0, 0, 15872, 15872, 0, 0, 0, 0, 0, 39, 116, 39, 120, 39, 39, 39, 0, 15872, 0, 15872, 0, 0, 0, 0, 0,
  16459, 16459, 16459, 16384, 16459, 16459, 16459, 16459, 16489, 0, 68096, 0, 16896, 0, 0, 0, 0, 0, 111, 7792, 67, 67,
  67, 0, 67, 67, 67, 67, 65, 66, 0, 5784, 5784, 156, 68096, 68096, 40, 40, 40, 40, 40, 40, 40, 40, 70, 70, 70, 70, 70,
  70, 18472, 70, 70, 70, 70, 18538, 0, 68096, 7792, 65, 66, 0, 0, 0, 7792, 68096, 68096, 0, 7792, 0, 0, 0, 0, 111, 7792,
  1721, 68096, 68096, 68096, 68096, 0, 0, 7680, 5700, 5700, 5700, 0, 5700, 5700, 5700, 5700, 65, 66, 5784, 6809, 5701,
  156, 39, 39, 39, 218, 0, 0, 0, 0, 19456, 0, 68096, 0, 193, 39, 39, 39, 39, 39, 39, 39, 39, 119, 39, 6809, 5865, 6299,
  156, 157, 156, 39, 39, 39, 252, 39, 254, 39, 39, 39, 293, 0, 39, 39, 39, 39, 39, 127, 39, 262, 39, 39, 39, 39, 39, 39,
  39, 195, 39, 0, 0, 65, 282, 283, 66, 284, 285, 5865, 5354, 157, 39, 39, 39, 39, 39, 243, 39, 0, 0, 229, 65, 232, 66,
  0, 39, 39, 39, 39, 265, 39, 39, 0, 342, 39, 39, 39, 0, 39, 39, 39, 121, 39, 128, 39, 39, 39, 39, 39, 0, 39, 328, 0, 0,
  362, 39, 0, 39, 39, 39, 39, 360, 39, 39, 5354, 39, 0, 39, 39, 0, 0, 165, 39, 39, 0, 0, 277, 0, 279, 58, 58, 5701,
  5701, 5701, 0, 5701, 5701, 5701, 5701, 0, 5865, 6299, 156, 157, 156, 39, 39, 39, 300, 39, 39, 39, 39, 139, 0, 0, 0,
  19968, 19968, 19968, 0, 0, 0, 0, 0, 0, 46592, 46592, 19968, 0, 19968, 19968, 19968, 19968, 19968, 19968, 0, 68096, 0,
  20992, 0, 0, 0, 0, 68096, 68096, 68096, 0, 95232, 68096, 0, 0, 21182, 0, 0, 0, 111, 7792, 22528, 0, 22528, 0, 0, 0, 0,
  0, 0, 68096, 0, 22016, 23209, 24576, 0, 0, 68096, 68096, 68096, 68096, 0, 0, 0, 14848, 17408, 18944, 22016, 24576,
  29184, 45056, 111, 7792, 23552, 0, 102400, 68096, 68096, 68096, 98816, 68096, 1721, 68096, 68096, 68096, 68096, 21504,
  25600, 111, 0, 0, 25258, 0, 0, 68096, 68096, 68096, 68096, 0, 0, 111, 0, 26112, 102400, 68096, 68096, 68096, 98816,
  68096, 1721, 68096, 68096, 68096, 68096, 0, 26373, 111, 0, 0, 6299, 156, 157, 156, 39, 39, 39, 317, 0, 0, 320, 0, 65,
  66, 0, 154, 154, 156, 39, 39, 39, 325, 39, 0, 39, 39, 39, 332, 39, 39, 39, 39, 210, 39, 39, 39, 214, 0, 0, 355, 39,
  39, 65, 66, 0, 155, 0, 156, 39, 39, 120, 39, 39, 39, 39, 39, 326, 39, 39, 27648, 27648, 27648, 0, 27648, 27648, 27648,
  27648, 27648, 0, 68096, 0, 65, 66, 0, 0, 0, 157, 68096, 68096, 103424, 68096, 68096, 41, 0, 0, 0, 0, 0, 0, 0, 12800,
  41, 41, 0, 0, 0, 59, 0, 0, 0, 39, 39, 200, 39, 39, 121, 39, 0, 0, 0, 0, 12800, 0, 68096, 0, 0, 41, 0, 59, 59, 41, 41,
  41, 0, 41, 41, 41, 41, 0, 0, 68137, 0, 0, 69691, 0, 69691, 69691, 0, 0, 0, 0, 28160, 0, 68096, 0, 150, 151, 0, 0, 0,
  158, 68137, 68137, 68137, 68137, 0, 0, 68137, 68137, 68137, 0, 0, 0, 0, 95744, 69691, 69691, 0, 0, 102400, 65, 66, 0,
  0, 0, 156, 39, 39, 0, 0, 102400, 68137, 68137, 68137, 98857, 68137, 107520, 0, 0, 0, 0, 101435, 104507, 101929, 68137,
  68137, 68137, 68137, 68137, 68137, 68137, 68137, 41, 1721, 68137, 68137, 68137, 68137, 0, 0, 111, 0, 0, 150, 0, 0,
  151, 0, 0, 0, 39, 39, 242, 39, 39, 122, 39, 0, 0, 0, 0, 22610, 0, 68096, 0, 0, 286, 157, 68137, 68137, 103465, 68137,
  68137, 68137, 68137, 68137, 0, 0, 0, 0, 0, 100393, 68137, 68137, 68137, 106537, 107561, 68137, 68137, 68137, 68137,
  68137, 109097, 95785, 68137, 105513, 69161, 68137, 68137, 108073, 0, 68137, 68137, 68137, 68137, 108544, 96256, 0, 0,
  0, 39, 39, 248, 39, 39, 134, 39, 138, 0, 141, 0, 99369, 68137, 0, 68137, 68137, 68137, 68137, 68137, 41, 68137,
  107049, 0, 68137, 68137, 103977, 105001, 68137, 68137, 68137, 106025, 108585, 68137, 68137, 68137, 0, 0, 0, 68137,
  98345, 99840, 97792, 0, 68137, 0, 68137, 68137, 97833, 99881, 0, 100905, 0, 96809, 97321, 0, 102912, 0, 28160, 0,
  28160, 0, 0, 0, 0, 0, 45568, 111, 7792, 0, 0, 0, 28672, 0, 0, 0, 0, 0, 68137, 68137, 68137, 0, 95273, 68137, 0, 58, 0,
  58, 58, 147, 0, 0, 0, 39, 247, 39, 39, 39, 137, 39, 0, 0, 0, 278, 279, 58, 58, 159, 39, 39, 39, 39, 182, 39, 0, 39, 0,
  39, 39, 0, 0, 39, 39, 125, 0, 0, 186, 39, 39, 159, 0, 0, 0, 0, 9829, 0, 68096, 0, 193, 39, 39, 197, 39, 39, 39, 39, 0,
  0, 39, 119, 262, 263, 39, 39, 39, 39, 39, 267, 0, 281, 65, 282, 283, 66, 284, 285, 39, 304, 39, 306, 0, 307, 39, 39,
  135, 39, 39, 0, 0, 0, 58, 0, 0, 314, 39, 39, 0, 0, 0, 320, 0, 0, 0, 9728, 0, 0, 0, 0, 0, 0, 68137, 68649, 42, 0, 0, 0,
  0, 0, 0, 0, 19968, 42, 42, 0, 0, 0, 58, 0, 0, 0, 65, 65, 65, 65, 65, 0, 0, 68096, 0, 0, 42, 0, 58, 58, 42, 42, 42, 0,
  86, 86, 86, 86, 0, 0, 39, 0, 193, 39, 39, 39, 39, 199, 39, 39, 0, 1721, 39, 248, 39, 39, 0, 0, 111, 43, 0, 0, 0, 0, 0,
  0, 0, 46080, 43, 43, 0, 0, 56, 58, 62, 0, 0, 0, 10832, 0, 0, 0, 0, 0, 39, 39, 174, 0, 43, 0, 58, 58, 43, 43, 43, 0,
  87, 87, 87, 87, 97, 97, 97, 97, 0, 0, 39, 0, 58, 58, 39, 39, 39, 0, 0, 355, 39, 39, 262, 39, 39, 217, 39, 39, 39, 39,
  0, 0, 119, 39, 167, 0, 0, 0, 5354, 157, 39, 287, 39, 39, 39, 0, 318, 0, 0, 0, 0, 28781, 0, 68096, 0, 39, 39, 331, 39,
  39, 39, 39, 39, 272, 39, 39, 39, 357, 39, 39, 39, 39, 39, 39, 212, 39, 44, 0, 0, 0, 0, 0, 0, 0, 39, 0, 44, 44, 0, 0,
  0, 58, 63, 0, 0, 0, 12800, 0, 0, 0, 0, 0, 0, 44, 0, 58, 58, 44, 76, 76, 76, 0, 88, 88, 88, 88, 88, 98, 98, 98, 0, 0,
  39, 0, 60, 60, 39, 39, 39, 0, 354, 0, 39, 39, 39, 122, 39, 39, 39, 119, 0, 0, 0, 58, 45, 0, 0, 0, 0, 0, 0, 0, 39, 39,
  39, 45, 45, 0, 0, 0, 58, 0, 0, 0, 66, 66, 66, 66, 66, 0, 0, 68096, 0, 0, 45, 0, 58, 58, 45, 45, 45, 0, 45, 45, 45, 45,
  45, 45, 99, 99, 0, 0, 39, 0, 39, 359, 39, 39, 39, 39, 0, 39, 264, 39, 131, 39, 39, 39, 39, 0, 0, 0, 58, 0, 58, 0, 145,
  146, 0, 148, 0, 0, 0, 13312, 0, 0, 0, 0, 0, 39, 115, 39, 39, 123, 39, 39, 65, 66, 0, 154, 154, 156, 39, 161, 39, 187,
  39, 39, 0, 0, 0, 0, 0, 58, 58, 193, 194, 39, 39, 39, 39, 39, 39, 273, 39, 262, 39, 119, 39, 39, 39, 39, 39, 39, 39,
  207, 268, 39, 39, 270, 39, 39, 39, 39, 0, 39, 39, 297, 280, 0, 65, 282, 283, 66, 284, 285, 290, 291, 292, 39, 0, 39,
  39, 39, 39, 39, 266, 39, 303, 39, 305, 39, 0, 307, 39, 39, 136, 39, 39, 0, 0, 0, 60, 0, 0, 0, 342, 39, 344, 39, 0, 39,
  39, 39, 198, 39, 39, 39, 119, 39, 39, 39, 39, 211, 212, 39, 39, 0, 0, 362, 39, 364, 365, 39, 39, 178, 39, 39, 39, 39,
  0, 0, 39, 39, 39, 0, 0, 0, 320, 0, 46, 0, 0, 0, 0, 0, 0, 0, 111, 0, 46, 46, 0, 0, 57, 58, 0, 0, 0, 67, 67, 67, 67, 67,
  17920, 0, 68096, 0, 0, 46, 0, 58, 58, 71, 71, 71, 0, 89, 89, 89, 89, 100, 0, 0, 39, 0, 39, 177, 39, 39, 39, 39, 39, 0,
  0, 0, 0, 0, 193, 39, 39, 39, 39, 200, 39, 39, 0, 58, 58, 0, 226, 0, 65, 66, 0, 0, 0, 156, 124, 39, 1721, 39, 258, 39,
  39, 0, 0, 111, 0, 342, 39, 39, 345, 0, 39, 39, 39, 212, 264, 39, 39, 39, 5354, 39, 0, 39, 39, 368, 0, 0, 0, 19456, 0,
  0, 0, 0, 0, 39, 173, 175, 39, 309, 39, 39, 39, 39, 39, 39, 301, 39, 329, 39, 39, 39, 39, 39, 39, 39, 302, 348, 39, 39,
  39, 39, 39, 39, 39, 334, 163, 0, 0, 39, 163, 39, 0, 0, 0, 82, 0, 0, 0, 0, 0, 12288, 12288, 12288, 119, 0, 0, 0, 0, 0,
  58, 58, 0, 0, 0, 65, 66, 5784, 0, 5701, 156, 39, 39, 39, 39, 350, 39, 39, 39, 39, 39, 311, 39, 39, 47, 0, 0, 0, 0, 0,
  0, 0, 111, 7792, 47, 47, 0, 0, 0, 58, 0, 0, 0, 156, 156, 156, 68096, 68096, 64, 47, 0, 58, 58, 47, 47, 47, 84, 90, 90,
  90, 90, 84, 0, 39, 0, 143, 58, 0, 58, 58, 0, 0, 0, 65, 66, 0, 124, 39, 39, 39, 39, 39, 184, 0, 0, 0, 20561, 0, 0, 0,
  0, 0, 172, 39, 39, 215, 216, 39, 0, 219, 0, 0, 0, 0, 44654, 0, 68096, 0, 308, 39, 39, 39, 39, 39, 39, 39, 312, 39,
  338, 39, 39, 39, 0, 0, 0, 0, 222, 0, 0, 343, 39, 39, 0, 39, 39, 118, 39, 39, 39, 129, 116, 39, 188, 39, 0, 0, 0, 0,
  279, 58, 58, 39, 208, 39, 39, 39, 39, 39, 39, 351, 352, 39, 39, 239, 39, 39, 242, 39, 39, 0, 39, 210, 39, 39, 39, 125,
  39, 140, 0, 142, 1721, 39, 242, 39, 39, 0, 0, 111, 0, 5354, 157, 39, 39, 39, 288, 39, 0, 358, 39, 39, 39, 39, 39, 205,
  39, 206, 39, 39, 39, 335, 0, 39, 39, 264, 39, 337, 341, 0, 39, 39, 39, 0, 39, 39, 196, 39, 39, 39, 39, 39, 271, 39,
  39, 39, 39, 127, 39, 39, 39, 39, 39, 0, 39, 39, 39, 39, 39, 39, 39, 0, 48, 0, 0, 0, 0, 0, 0, 0, 323, 39, 48, 48, 0, 0,
  0, 58, 0, 0, 0, 156, 157, 156, 39, 39, 0, 336, 39, 39, 39, 39, 0, 295, 39, 39, 0, 48, 0, 58, 58, 72, 72, 72, 0, 72,
  72, 72, 72, 0, 0, 39, 0, 0, 58, 0, 58, 58, 0, 0, 149, 1721, 39, 39, 39, 260, 0, 0, 111, 39, 339, 119, 39, 0, 0, 0, 0,
  13415, 0, 68096, 111, 0, 0, 39, 39, 39, 346, 39, 347, 39, 349, 39, 39, 39, 39, 39, 39, 0, 307, 39, 39, 0, 39, 117,
  119, 39, 125, 39, 39, 39, 275, 39, 39, 176, 39, 39, 39, 39, 167, 39, 0, 39, 367, 39, 39, 0, 0, 0, 156, 157, 156, 39,
  237, 173, 175, 39, 176, 0, 0, 0, 0, 15872, 0, 68096, 0, 39, 39, 269, 39, 39, 39, 39, 39, 129, 39, 39, 39, 39, 39, 316,
  0, 0, 0, 0, 0, 0, 68096, 68096, 68096, 39, 315, 39, 0, 0, 0, 356, 39, 39, 240, 39, 39, 39, 244, 0, 0, 0, 24147, 0, 0,
  0, 0, 0, 27648, 27648, 27648, 39, 203, 39, 39, 39, 39, 203, 39, 39, 251, 240, 39, 39, 255, 39, 0, 276, 0, 0, 0, 58,
  58, 0, 0, 0, 228, 231, 0, 49, 0, 0, 0, 0, 0, 0, 0, 8192, 8192, 49, 49, 0, 0, 0, 58, 0, 0, 0, 156, 157, 156, 236, 39,
  0, 49, 0, 58, 58, 49, 49, 49, 0, 91, 91, 91, 91, 0, 0, 39, 0, 0, 114, 39, 39, 39, 39, 39, 39, 166, 39, 39, 0, 164, 0,
  0, 39, 164, 39, 0, 0, 0, 156, 157, 156, 68096, 68096, 68096, 68096, 26624, 0, 68096, 68096, 68096, 68096, 68096, 0, 0,
  0, 0, 0, 39, 315, 39, 0, 0, 0, 0, 0, 0, 0, 0, 96, 39, 330, 39, 39, 39, 39, 39, 39, 180, 39, 183, 0, 50, 0, 0, 0, 0, 0,
  0, 0, 14410, 14410, 50, 50, 0, 0, 0, 61, 0, 0, 0, 157, 157, 156, 68096, 68096, 0, 50, 0, 61, 61, 50, 50, 50, 0, 92,
  92, 92, 92, 0, 0, 39, 0, 0, 39, 195, 39, 39, 39, 39, 195, 39, 39, 39, 313, 58, 58, 225, 0, 0, 65, 66, 0, 0, 0, 156,
  125, 39, 0, 0, 245, 39, 39, 39, 39, 39, 181, 39, 39, 0, 1721, 257, 39, 259, 39, 0, 0, 111, 0, 5354, 157, 241, 39, 39,
  39, 289, 51, 0, 0, 0, 0, 0, 0, 0, 16459, 16459, 51, 51, 0, 0, 0, 58, 0, 0, 0, 158, 235, 156, 68137, 68137, 68137,
  68137, 0, 68137, 68137, 68137, 68137, 68137, 68137, 68137, 0, 0, 51, 0, 58, 58, 73, 77, 77, 77, 0, 93, 93, 93, 93, 0,
  0, 39, 0, 0, 39, 196, 39, 39, 39, 39, 39, 241, 39, 39, 39, 0, 39, 204, 39, 39, 39, 39, 39, 39, 253, 39, 39, 39, 223,
  224, 0, 0, 0, 65, 66, 0, 0, 0, 156, 159, 39, 39, 250, 39, 39, 39, 39, 39, 256, 1721, 196, 39, 39, 39, 0, 0, 111, 39,
  39, 299, 39, 39, 39, 39, 39, 294, 39, 296, 39, 39, 39, 324, 39, 39, 0, 39, 39, 209, 39, 39, 39, 39, 39, 264, 39, 39,
  39, 113, 39, 39, 39, 39, 126, 39, 130, 0, 58, 144, 58, 58, 0, 0, 0, 65, 66, 154, 160, 39, 39, 132, 39, 39, 39, 0, 0,
  0, 39, 39, 202, 39, 39, 39, 39, 39, 39, 39, 333, 39, 39, 39, 274, 39, 39, 39, 39, 39, 39, 39, 160, 0, 0, 0, 0, 20587,
  0, 68096, 0, 39, 298, 39, 39, 39, 39, 39, 39, 179, 39, 39, 39, 0, 0, 319, 0, 0, 39, 39, 310, 39, 39, 39, 39, 39, 189,
  0, 0, 0, 0, 10854, 0, 68096, 0, 321, 0, 0, 0, 0, 322, 39, 39, 217, 0, 0, 220, 0, 0, 0, 171, 0, 39, 39, 39, 39, 124,
  39, 39, 52, 0, 0, 0, 54, 0, 0, 0, 0, 45568, 68096, 68096, 68096, 68096, 0, 11264, 0, 0, 52, 52, 0, 0, 0, 58, 0, 0, 0,
  246, 39, 39, 39, 39, 0, 0, 340, 0, 0, 52, 0, 58, 58, 52, 78, 78, 78, 0, 94, 94, 94, 94, 0, 0, 39, 0, 53, 0, 0, 0, 0,
  55, 0, 0, 0, 363, 0, 39, 39, 39, 39, 201, 39, 39, 53, 53, 0, 0, 0, 58, 0, 0, 0, 5354, 157, 156, 68096, 68096, 0, 53,
  0, 58, 58, 53, 53, 53, 0, 95, 95, 95, 95, 0, 0, 39, 0, 39, 133, 39, 39, 39, 0, 0, 0, 221, 0, 238, 39, 39, 39, 39, 39,
  39, 0, 327, 39, 58, 58, 0, 0, 0, 229, 232, 0, 0, 0, 25279, 0, 0, 111, 7792, 136, 0, 0, 39, 166, 39, 0, 0, 0, 5700,
  5700, 5700, 5700, 5700, 0, 0, 39, 0, 119, 39, 39, 353, 0, 0, 39, 39, 39, 0, 39, 39, 44032, 44032, 44032, 0, 44032,
  44032, 44032, 44032, 0, 0, 68096, 0, 0, 0, 0, 44629, 0, 0, 0, 0, 24172, 0, 68096, 0, 0, 0, 0, 46080, 0, 0, 46080,
  46080, 0, 0, 46080, 0, 0, 46080, 46080, 0, 46080, 0, 0, 0, 39, 0, 39, 39, 39, 39, 39, 361, 46080, 46080, 46080, 46080,
  46080, 0, 68096, 0, 16896, 68096, 68096, 68096, 0, 0, 68096, 68096, 68096, 0, 11264, 46592, 46592, 46592, 0, 46592,
  46592, 46592, 46592, 0, 0, 68096, 0, 0, 0, 2048, 2048, 0, 2048, 0, 2048, 2048, 0, 0, 0, 0, 0, 0, 68096, 68608, 0, 0,
  2048, 2048, 2048, 0, 68096, 0, 0, 0, 27136, 0, 0, 0, 0, 0, 44032, 44032, 44032, 69632, 69632, 0, 0, 102400, 0, 0, 0,
  39, 0, 39, 366, 39
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  276, 279, 286, 282, 289, 292, 296, 300, 304, 308, 321, 321, 321, 324, 411, 414, 471, 312, 316, 331, 325, 320, 335,
  364, 336, 340, 605, 371, 321, 321, 321, 321, 321, 321, 322, 432, 413, 470, 344, 354, 359, 349, 403, 321, 321, 335,
  348, 370, 321, 321, 321, 321, 321, 321, 324, 411, 421, 423, 353, 358, 335, 320, 321, 321, 321, 320, 321, 321, 322,
  433, 422, 621, 363, 319, 321, 321, 321, 321, 321, 432, 463, 319, 321, 321, 322, 463, 319, 321, 462, 320, 368, 323,
  446, 325, 325, 375, 379, 386, 390, 394, 398, 402, 325, 325, 325, 517, 325, 440, 325, 325, 529, 325, 408, 504, 325,
  325, 419, 325, 427, 431, 325, 325, 325, 325, 325, 325, 325, 437, 439, 325, 325, 325, 325, 445, 450, 460, 325, 325,
  467, 541, 325, 325, 325, 325, 325, 325, 517, 325, 441, 325, 325, 325, 444, 452, 325, 325, 441, 510, 325, 325, 325,
  438, 552, 325, 443, 503, 455, 439, 325, 325, 325, 437, 442, 503, 455, 551, 325, 442, 523, 550, 551, 524, 325, 454,
  325, 475, 502, 479, 483, 487, 489, 493, 497, 501, 325, 325, 325, 508, 614, 572, 325, 598, 516, 521, 511, 528, 533,
  538, 382, 325, 325, 548, 325, 325, 325, 325, 325, 325, 553, 557, 571, 414, 325, 403, 577, 587, 512, 607, 534, 563,
  326, 559, 325, 325, 325, 325, 325, 325, 508, 569, 325, 325, 325, 576, 586, 592, 581, 563, 327, 325, 325, 325, 456,
  558, 325, 404, 585, 591, 544, 565, 596, 325, 325, 557, 404, 602, 544, 557, 415, 404, 602, 611, 597, 592, 618, 421,
  24592, 8413184, 16801792, 24576, 24576, 24576, 24576, 24704, 24576, 24584, 8413200, 16801808, 1090543616, 1073766400,
  24600, 1073766408, 32128, 8421232, -1736376464, -1719599248, -1736376464, -662634640, -1736376456, -885563384,
  -1736376464, -1736376456, -1736376464, -1736376452, -1736376464, -1736376464, -1736376456, -1736376456, -40952, 8192,
  16, 16384, 1024, 16896, 80, 48, 80, 268435456, 0, 16, 0, 16, 16, 16, 16, 0, 0, 0, 0, 2, 4, 80, 16, 196608, 2097152,
  80, 16, 16, 16, 80, 524288, 6291456, 67108864, 805306368, 4096, 1024, 2048, 512, 4, 16, 16, 16, 131072, 1024, 512,
  512, 80, 16, 16, 16, 48, 16, 80, 16, 80, 16, 16, 4, 16, 512, 16, 0, 0, 16384, 16384, 134217728, 0, 1140850688, 64,
  2112, 64, 2112, 0, 1, 2, 28, 0, 2097152, -2145386495, -2145386495, -2145386431, -2141192191, -2145386431, 14022120,
  -1306525631, -1306525631, -1306525631, -1306525631, -1239416767, -165674943, -165674943, -165674943, 33554431, 0, 0,
  0, 16, 0, 1280, 12288, 360448, 0, 128, 128, 128, 0, 0, 0, 4, 335544320, -536870912, 0, 0, 256, 256, 256, 256, 3, 16,
  1792, 1015808, 16777216, 0, 0, 0, 128, 0, 0, 134217728, 0, 0, 67108864, 1073741824, 0, 0, -2147483648, 0, 0, 0, 32,
  8192, 262144, 0, 33554432, 268435456, 536870912, 0, 0, 0, 524288, 268435456, -1610612736, 0, 0, 512, 16, 16, 0,
  67108864, -536870912, 0, 256, 256, 1024, 7168, 131072, 524288, 2097152, 33554432, 4, 2080, 33554432, 33554432, 128,
  33554432, 33554432, 2080, 33556512, 2105872, 69542416, 69542416, 103096848, 54526336, 71300697, 71300697, 104855129,
  71300697, 104855129, 104855129, 104855131, 104855135, 62914944, 0, 0, 0, 33554432, 268435456, -1610612736, 0, 131072,
  524288, 0, 0, 0, 384, 0, 8192, 0, 0, 0, 134217728, 73728, 262144, 0, 0, 268435456, 536870912, 1073741824, 16777216, 0,
  0, 1, -2147483648, 24, 64, 1024, 4096, 24576, 122880, 393216, 1572864, 0, 512, 917504, 0, 1024, 4096, 16384, 0,
  25165824, 0, 0, 1073741824, 0, 0, 0, 131072, 524288, 0, 4, 0, 0, 0, 32768, 131072, 524288, 1048576, 0, 0, 4, 0, 32,
  2048, 0, 0, 128, 16, 512, 0, 8192, 0, 8, 1024, 4096, 16384, 8192, 0, 0, 65536, 262144, 0, 262144, 256, 0, 0, 0, 2, 4,
  0, 0, 16, 512, 65536, 256, 0, 0, 16384, 0, 0, 1, 8, 1024, 4096, 0, 4, 0, 0, 32, 4, 0, 16, 256, 512, 16, 48
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "END",
  "Shebang",
  "EOF",
  "Identifier",
  "'null'",
  "BooleanLiteral",
  "IdentifierName",
  "StringLiteral",
  "RegularExpressionLiteral",
  "DecimalLiteral",
  "HexIntegerLiteral",
  "OctalIntegerLiteral",
  "WhiteSpace",
  "Comment",
  "'!'",
  "'!='",
  "'!=='",
  "'%'",
  "'%='",
  "'&amp;'",
  "'&amp;&amp;'",
  "'&amp;='",
  "'('",
  "')'",
  "'*'",
  "'*='",
  "'+'",
  "'++'",
  "'+='",
  "','",
  "'-'",
  "'--'",
  "'-='",
  "'.'",
  "'/'",
  "'/='",
  "':'",
  "';'",
  "'<'",
  "'<<'",
  "'<<='",
  "'<='",
  "'='",
  "'=='",
  "'==='",
  "'>'",
  "'>='",
  "'>>'",
  "'>>='",
  "'>>>'",
  "'>>>='",
  "'?'",
  "'['",
  "']'",
  "'^'",
  "'^='",
  "'break'",
  "'case'",
  "'catch'",
  "'continue'",
  "'debugger'",
  "'default'",
  "'delete'",
  "'do'",
  "'else'",
  "'finally'",
  "'for'",
  "'function'",
  "'get'",
  "'if'",
  "'in'",
  "'instanceof'",
  "'new'",
  "'return'",
  "'set'",
  "'switch'",
  "'this'",
  "'throw'",
  "'try'",
  "'typeof'",
  "'var'",
  "'void'",
  "'while'",
  "'with'",
  "'{'",
  "'|'",
  "'|='",
  "'||'",
  "'}'",
  "'~'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 512,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 512
    let $end := $end - $result idiv 128
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 128 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 4)
    let $current := $current + 1
    let $i0 := 512 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 8
    let $next-state := $p:TRANSITION[$i0 mod 8 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 511) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 512, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 2
    let $i0 := $t * 368 + $state - 1
    let $i1 := $i0 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[4 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[8 + $m]
};

(:~
 : Parse DebuggerStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DebuggerStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(61, $input, $state)               (: 'debugger' :)
  let $state := p:lookahead1W(15, $input, $state)           (: END | EOF | WhiteSpace | Comment | ';' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DebuggerStatement", $count, $begin, $end)
};

(:~
 : Try parsing DebuggerStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DebuggerStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(61, $input, $state)              (: 'debugger' :)
  let $state := p:lookahead1W(15, $input, $state)           (: END | EOF | WhiteSpace | Comment | ';' | '}' :)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse Finally.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Finally($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(66, $input, $state)               (: 'finally' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Finally", $count, $begin, $end)
};

(:~
 : Try parsing Finally.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Finally($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(66, $input, $state)              (: 'finally' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:try-Block($input, $state)
  return $state
};

(:~
 : Parse Catch.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Catch($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(59, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consume(23, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:consume(4, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | ')' :)
  let $state := p:consume(24, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Catch", $count, $begin, $end)
};

(:~
 : Try parsing Catch.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Catch($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(59, $input, $state)              (: 'catch' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consumeT(23, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:consumeT(4, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | ')' :)
  let $state := p:consumeT(24, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:try-Block($input, $state)
  return $state
};

(:~
 : Parse TryStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(79, $input, $state)               (: 'try' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Block($input, $state)
  let $state := p:lookahead1W(12, $input, $state)           (: WhiteSpace | Comment | 'catch' | 'finally' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 59) then                       (: 'catch' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Catch($input, $state)
      let $state := p:lookahead1W(35, $input, $state)       (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'default' | 'delete' | 'do' |
                                                               'else' | 'finally' | 'for' | 'function' | 'if' | 'new' |
                                                               'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '}' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 66) then                   (: 'finally' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Finally($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Finally($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TryStatement", $count, $begin, $end)
};

(:~
 : Try parsing TryStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(79, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:try-Block($input, $state)
  let $state := p:lookahead1W(12, $input, $state)           (: WhiteSpace | Comment | 'catch' | 'finally' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 59) then                       (: 'catch' :)
      let $state := p:try-Catch($input, $state)
      let $state := p:lookahead1W(35, $input, $state)       (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'default' | 'delete' | 'do' |
                                                               'else' | 'finally' | 'for' | 'function' | 'if' | 'new' |
                                                               'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '}' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 66) then                   (: 'finally' :)
          let $state := p:try-Finally($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Finally($input, $state)
      return $state
  return $state
};

(:~
 : Parse ThrowStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ThrowStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(78, $input, $state)               (: 'throw' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ThrowStatement", $count, $begin, $end)
};

(:~
 : Try parsing ThrowStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ThrowStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(78, $input, $state)              (: 'throw' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state := p:try-Expression($input, $state)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production DefaultClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(32, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 58                                (: 'case' :)
       or $state[$p:l1] = 89) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Statement($input, $state)
        return p:parse-DefaultClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DefaultClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DefaultClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(32, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 58                                (: 'case' :)
       or $state[$p:l1] = 89) then                          (: '}' :)
        $state
      else
        let $state := p:try-Statement($input, $state)
        return p:try-DefaultClause-1($input, $state)
};

(:~
 : Parse DefaultClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(62, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(3, $input, $state)            (: WhiteSpace | Comment | ':' :)
  let $state := p:consume(37, $input, $state)               (: ':' :)
  let $state := p:parse-DefaultClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultClause", $count, $begin, $end)
};

(:~
 : Try parsing DefaultClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DefaultClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(62, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(3, $input, $state)            (: WhiteSpace | Comment | ':' :)
  let $state := p:consumeT(37, $input, $state)              (: ':' :)
  let $state := p:try-DefaultClause-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CaseClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'default' | 'delete' | 'do' |
                                                               'for' | 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 58                                (: 'case' :)
       or $state[$p:l1] = 62                                (: 'default' :)
       or $state[$p:l1] = 89) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Statement($input, $state)
        return p:parse-CaseClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CaseClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'default' | 'delete' | 'do' |
                                                               'for' | 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 58                                (: 'case' :)
       or $state[$p:l1] = 62                                (: 'default' :)
       or $state[$p:l1] = 89) then                          (: '}' :)
        $state
      else
        let $state := p:try-Statement($input, $state)
        return p:try-CaseClause-1($input, $state)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(58, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:consume(37, $input, $state)               (: ':' :)
  let $state := p:parse-CaseClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseClause", $count, $begin, $end)
};

(:~
 : Try parsing CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(58, $input, $state)              (: 'case' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:try-Expression($input, $state)
  let $state := p:consumeT(37, $input, $state)              (: ':' :)
  let $state := p:try-CaseClause-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CaseBlock (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseBlock-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(14, $input, $state)         (: WhiteSpace | Comment | 'case' | 'default' | '}' :)
    return
      if ($state[$p:l1] != 58) then                         (: 'case' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-CaseClause($input, $state)
        return p:parse-CaseBlock-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CaseBlock (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseBlock-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(14, $input, $state)         (: WhiteSpace | Comment | 'case' | 'default' | '}' :)
    return
      if ($state[$p:l1] != 58) then                         (: 'case' :)
        $state
      else
        let $state := p:try-CaseClause($input, $state)
        return p:try-CaseBlock-1($input, $state)
};

(:~
 : Parse the 2nd loop of production CaseBlock (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseBlock-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 58) then                           (: 'case' :)
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-CaseClause($input, $state)
      return p:parse-CaseBlock-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production CaseBlock (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseBlock-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 58) then                           (: 'case' :)
      $state
    else
      let $state := p:try-CaseClause($input, $state)
      return p:try-CaseBlock-2($input, $state)
};

(:~
 : Parse CaseBlock.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseBlock($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(85, $input, $state)               (: '{' :)
  let $state := p:parse-CaseBlock-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: 'default' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-DefaultClause($input, $state)
      let $state := p:parse-CaseBlock-2($input, $state)
      return $state
    else
      $state
  let $state := p:consume(89, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseBlock", $count, $begin, $end)
};

(:~
 : Try parsing CaseBlock.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseBlock($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(85, $input, $state)              (: '{' :)
  let $state := p:try-CaseBlock-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: 'default' :)
      let $state := p:try-DefaultClause($input, $state)
      let $state := p:try-CaseBlock-2($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(89, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse SwitchStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(76, $input, $state)               (: 'switch' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consume(23, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:consume(24, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-CaseBlock($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchStatement", $count, $begin, $end)
};

(:~
 : Try parsing SwitchStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(76, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consumeT(23, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:try-Expression($input, $state)
  let $state := p:consumeT(24, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:try-CaseBlock($input, $state)
  return $state
};

(:~
 : Parse LabelledStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LabelledStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(4, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(3, $input, $state)            (: WhiteSpace | Comment | ':' :)
  let $state := p:consume(37, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(28, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Statement($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LabelledStatement", $count, $begin, $end)
};

(:~
 : Try parsing LabelledStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LabelledStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(4, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(3, $input, $state)            (: WhiteSpace | Comment | ':' :)
  let $state := p:consumeT(37, $input, $state)              (: ':' :)
  let $state := p:lookahead1W(28, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
  let $state := p:try-Statement($input, $state)
  return $state
};

(:~
 : Parse WithStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WithStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(84, $input, $state)               (: 'with' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consume(23, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:consume(24, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(28, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Statement($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WithStatement", $count, $begin, $end)
};

(:~
 : Try parsing WithStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WithStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(84, $input, $state)              (: 'with' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consumeT(23, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:try-Expression($input, $state)
  let $state := p:consumeT(24, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(28, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
  let $state := p:try-Statement($input, $state)
  return $state
};

(:~
 : Parse ReturnStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReturnStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(74, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(26, $input, $state)           (: END | EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '}' | '~' :)
  let $state :=
    if ($state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 1                             (: END :)
         and $state[$p:l1] != 3                             (: EOF :)
         and $state[$p:l1] != 38                            (: ';' :)
         and $state[$p:l1] != 89) then                      (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReturnStatement", $count, $begin, $end)
};

(:~
 : Try parsing ReturnStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReturnStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(74, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(26, $input, $state)           (: END | EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '}' | '~' :)
  let $state :=
    if ($state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 1                             (: END :)
         and $state[$p:l1] != 3                             (: EOF :)
         and $state[$p:l1] != 38                            (: ';' :)
         and $state[$p:l1] != 89) then                      (: '}' :)
      let $state := p:try-Expression($input, $state)
      return $state
    else
      $state
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse BreakStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BreakStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(57, $input, $state)               (: 'break' :)
  let $state := p:lookahead1W(17, $input, $state)           (: END | EOF | Identifier | WhiteSpace | Comment | ';' | '}' :)
  let $state :=
    if ($state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:consume(4, $input, $state)            (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: END | EOF | WhiteSpace | Comment | ';' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BreakStatement", $count, $begin, $end)
};

(:~
 : Try parsing BreakStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BreakStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(57, $input, $state)              (: 'break' :)
  let $state := p:lookahead1W(17, $input, $state)           (: END | EOF | Identifier | WhiteSpace | Comment | ';' | '}' :)
  let $state :=
    if ($state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:consumeT(4, $input, $state)           (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: END | EOF | WhiteSpace | Comment | ';' | '}' :)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse ContinueStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContinueStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(60, $input, $state)               (: 'continue' :)
  let $state := p:lookahead1W(17, $input, $state)           (: END | EOF | Identifier | WhiteSpace | Comment | ';' | '}' :)
  let $state :=
    if ($state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:consume(4, $input, $state)            (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: END | EOF | WhiteSpace | Comment | ';' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContinueStatement", $count, $begin, $end)
};

(:~
 : Try parsing ContinueStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ContinueStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(60, $input, $state)              (: 'continue' :)
  let $state := p:lookahead1W(17, $input, $state)           (: END | EOF | Identifier | WhiteSpace | Comment | ';' | '}' :)
  let $state :=
    if ($state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:consumeT(4, $input, $state)           (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(15, $input, $state)           (: END | EOF | WhiteSpace | Comment | ';' | '}' :)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse InitialiserNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitialiserNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(43, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AssignmentExpressionNoIn($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InitialiserNoIn", $count, $begin, $end)
};

(:~
 : Try parsing InitialiserNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InitialiserNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(43, $input, $state)              (: '=' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:try-AssignmentExpressionNoIn($input, $state)
  return $state
};

(:~
 : Parse VariableDeclarationNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(4, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(16, $input, $state)           (: WhiteSpace | Comment | ',' | ';' | '=' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '=' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-InitialiserNoIn($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclarationNoIn", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclarationNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(4, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(16, $input, $state)           (: WhiteSpace | Comment | ',' | ';' | '=' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '=' :)
      let $state := p:try-InitialiserNoIn($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production VariableDeclarationListNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationListNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consume(30, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VariableDeclarationNoIn($input, $state)
      return p:parse-VariableDeclarationListNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production VariableDeclarationListNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationListNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(30, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-VariableDeclarationNoIn($input, $state)
      return p:try-VariableDeclarationListNoIn-1($input, $state)
};

(:~
 : Parse VariableDeclarationListNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationListNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-VariableDeclarationNoIn($input, $state)
  let $state := p:parse-VariableDeclarationListNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclarationListNoIn", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclarationListNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationListNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-VariableDeclarationNoIn($input, $state)
  let $state := p:try-VariableDeclarationListNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production RelationalExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelationalExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39                                 (: '<' :)
    and $state[$p:l1] != 42                                 (: '<=' :)
    and $state[$p:l1] != 46                                 (: '>' :)
    and $state[$p:l1] != 47                                 (: '>=' :)
    and $state[$p:l1] != 72) then                           (: 'instanceof' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: '<' :)
          let $state := p:consume(39, $input, $state)       (: '<' :)
          return $state
        else if ($state[$p:l1] = 46) then                   (: '>' :)
          let $state := p:consume(46, $input, $state)       (: '>' :)
          return $state
        else if ($state[$p:l1] = 42) then                   (: '<=' :)
          let $state := p:consume(42, $input, $state)       (: '<=' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: '>=' :)
          let $state := p:consume(47, $input, $state)       (: '>=' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(72, $input, $state)       (: 'instanceof' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ShiftExpression($input, $state)
      return p:parse-RelationalExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production RelationalExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelationalExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39                                 (: '<' :)
    and $state[$p:l1] != 42                                 (: '<=' :)
    and $state[$p:l1] != 46                                 (: '>' :)
    and $state[$p:l1] != 47                                 (: '>=' :)
    and $state[$p:l1] != 72) then                           (: 'instanceof' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: '<' :)
          let $state := p:consumeT(39, $input, $state)      (: '<' :)
          return $state
        else if ($state[$p:l1] = 46) then                   (: '>' :)
          let $state := p:consumeT(46, $input, $state)      (: '>' :)
          return $state
        else if ($state[$p:l1] = 42) then                   (: '<=' :)
          let $state := p:consumeT(42, $input, $state)      (: '<=' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: '>=' :)
          let $state := p:consumeT(47, $input, $state)      (: '>=' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consumeT(72, $input, $state)      (: 'instanceof' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-ShiftExpression($input, $state)
      return p:try-RelationalExpressionNoIn-1($input, $state)
};

(:~
 : Parse RelationalExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelationalExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ShiftExpression($input, $state)
  let $state := p:parse-RelationalExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelationalExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing RelationalExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelationalExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ShiftExpression($input, $state)
  let $state := p:try-RelationalExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production EqualityExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EqualityExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 16                                 (: '!=' :)
    and $state[$p:l1] != 17                                 (: '!==' :)
    and $state[$p:l1] != 44                                 (: '==' :)
    and $state[$p:l1] != 45) then                           (: '===' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 44) then                   (: '==' :)
          let $state := p:consume(44, $input, $state)       (: '==' :)
          return $state
        else if ($state[$p:l1] = 16) then                   (: '!=' :)
          let $state := p:consume(16, $input, $state)       (: '!=' :)
          return $state
        else if ($state[$p:l1] = 45) then                   (: '===' :)
          let $state := p:consume(45, $input, $state)       (: '===' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(17, $input, $state)       (: '!==' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RelationalExpressionNoIn($input, $state)
      return p:parse-EqualityExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production EqualityExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EqualityExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 16                                 (: '!=' :)
    and $state[$p:l1] != 17                                 (: '!==' :)
    and $state[$p:l1] != 44                                 (: '==' :)
    and $state[$p:l1] != 45) then                           (: '===' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 44) then                   (: '==' :)
          let $state := p:consumeT(44, $input, $state)      (: '==' :)
          return $state
        else if ($state[$p:l1] = 16) then                   (: '!=' :)
          let $state := p:consumeT(16, $input, $state)      (: '!=' :)
          return $state
        else if ($state[$p:l1] = 45) then                   (: '===' :)
          let $state := p:consumeT(45, $input, $state)      (: '===' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consumeT(17, $input, $state)      (: '!==' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-RelationalExpressionNoIn($input, $state)
      return p:try-EqualityExpressionNoIn-1($input, $state)
};

(:~
 : Parse EqualityExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EqualityExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-RelationalExpressionNoIn($input, $state)
  let $state := p:parse-EqualityExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EqualityExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing EqualityExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EqualityExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-RelationalExpressionNoIn($input, $state)
  let $state := p:try-EqualityExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseANDExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseANDExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 20) then                           (: '&' :)
      $state
    else
      let $state := p:consume(20, $input, $state)           (: '&' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EqualityExpressionNoIn($input, $state)
      return p:parse-BitwiseANDExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseANDExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseANDExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 20) then                           (: '&' :)
      $state
    else
      let $state := p:consumeT(20, $input, $state)          (: '&' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-EqualityExpressionNoIn($input, $state)
      return p:try-BitwiseANDExpressionNoIn-1($input, $state)
};

(:~
 : Parse BitwiseANDExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseANDExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EqualityExpressionNoIn($input, $state)
  let $state := p:parse-BitwiseANDExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseANDExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseANDExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseANDExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EqualityExpressionNoIn($input, $state)
  let $state := p:try-BitwiseANDExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseXORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseXORExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 55) then                           (: '^' :)
      $state
    else
      let $state := p:consume(55, $input, $state)           (: '^' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseANDExpressionNoIn($input, $state)
      return p:parse-BitwiseXORExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseXORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseXORExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 55) then                           (: '^' :)
      $state
    else
      let $state := p:consumeT(55, $input, $state)          (: '^' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-BitwiseANDExpressionNoIn($input, $state)
      return p:try-BitwiseXORExpressionNoIn-1($input, $state)
};

(:~
 : Parse BitwiseXORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseXORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseANDExpressionNoIn($input, $state)
  let $state := p:parse-BitwiseXORExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseXORExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseXORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseXORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseANDExpressionNoIn($input, $state)
  let $state := p:try-BitwiseXORExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseORExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 86) then                           (: '|' :)
      $state
    else
      let $state := p:consume(86, $input, $state)           (: '|' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseXORExpressionNoIn($input, $state)
      return p:parse-BitwiseORExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseORExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 86) then                           (: '|' :)
      $state
    else
      let $state := p:consumeT(86, $input, $state)          (: '|' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-BitwiseXORExpressionNoIn($input, $state)
      return p:try-BitwiseORExpressionNoIn-1($input, $state)
};

(:~
 : Parse BitwiseORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseXORExpressionNoIn($input, $state)
  let $state := p:parse-BitwiseORExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseORExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseXORExpressionNoIn($input, $state)
  let $state := p:try-BitwiseORExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LogicalANDExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalANDExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 21) then                           (: '&&' :)
      $state
    else
      let $state := p:consume(21, $input, $state)           (: '&&' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseORExpressionNoIn($input, $state)
      return p:parse-LogicalANDExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LogicalANDExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalANDExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 21) then                           (: '&&' :)
      $state
    else
      let $state := p:consumeT(21, $input, $state)          (: '&&' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-BitwiseORExpressionNoIn($input, $state)
      return p:try-LogicalANDExpressionNoIn-1($input, $state)
};

(:~
 : Parse LogicalANDExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalANDExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseORExpressionNoIn($input, $state)
  let $state := p:parse-LogicalANDExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LogicalANDExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing LogicalANDExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalANDExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseORExpressionNoIn($input, $state)
  let $state := p:try-LogicalANDExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LogicalORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalORExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 88) then                           (: '||' :)
      $state
    else
      let $state := p:consume(88, $input, $state)           (: '||' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LogicalANDExpressionNoIn($input, $state)
      return p:parse-LogicalORExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LogicalORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalORExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 88) then                           (: '||' :)
      $state
    else
      let $state := p:consumeT(88, $input, $state)          (: '||' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-LogicalANDExpressionNoIn($input, $state)
      return p:try-LogicalORExpressionNoIn-1($input, $state)
};

(:~
 : Parse LogicalORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LogicalANDExpressionNoIn($input, $state)
  let $state := p:parse-LogicalORExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LogicalORExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing LogicalORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LogicalANDExpressionNoIn($input, $state)
  let $state := p:try-LogicalORExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ConditionalExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConditionalExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 52) then                     (: '?' :)
        let $state := p:memoized($state, 9)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(52, $input, $state)    (: '?' :)
            let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
            let $state := p:try-AssignmentExpression($input, $state)
            let $state := p:consumeT(37, $input, $state)    (: ':' :)
            let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
            let $state := p:try-AssignmentExpressionNoIn($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 9)
              else
                p:memoize($backtrack, $state, -2, 9)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(52, $input, $state)         (: '?' :)
        let $state := p:lookahead1W(22, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-AssignmentExpression($input, $state)
        let $state := p:consume(37, $input, $state)         (: ':' :)
        let $state := p:lookahead1W(22, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-AssignmentExpressionNoIn($input, $state)
        return p:parse-ConditionalExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ConditionalExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ConditionalExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 52) then                     (: '?' :)
        let $state := p:memoized($state, 9)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(52, $input, $state)    (: '?' :)
            let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
            let $state := p:try-AssignmentExpression($input, $state)
            let $state := p:consumeT(37, $input, $state)    (: ':' :)
            let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
            let $state := p:try-AssignmentExpressionNoIn($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 9)
              else
                p:memoize($backtrack, $state, -2, 9)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consumeT(52, $input, $state)        (: '?' :)
        let $state := p:lookahead1W(22, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
        let $state := p:try-AssignmentExpression($input, $state)
        let $state := p:consumeT(37, $input, $state)        (: ':' :)
        let $state := p:lookahead1W(22, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
        let $state := p:try-AssignmentExpressionNoIn($input, $state)
        return p:try-ConditionalExpressionNoIn-1($input, $state)
};

(:~
 : Parse ConditionalExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConditionalExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LogicalORExpressionNoIn($input, $state)
  let $state := p:parse-ConditionalExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ConditionalExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing ConditionalExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ConditionalExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LogicalORExpressionNoIn($input, $state)
  let $state := p:try-ConditionalExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse AssignmentExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AssignmentExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 15                            (: '!' :)
         and $state[$p:l1] != 27                            (: '+' :)
         and $state[$p:l1] != 28                            (: '++' :)
         and $state[$p:l1] != 31                            (: '-' :)
         and $state[$p:l1] != 32                            (: '--' :)
         and $state[$p:l1] != 63                            (: 'delete' :)
         and $state[$p:l1] != 80                            (: 'typeof' :)
         and $state[$p:l1] != 82                            (: 'void' :)
         and $state[$p:l1] != 90) then                      (: '~' :)
      let $state := p:memoized($state, 8)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-LeftHandSideExpression($input, $state)
          let $state := p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpressionNoIn($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 8)
            else
              p:memoize($backtrack, $state, -2, 8)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:parse-LeftHandSideExpression($input, $state)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpressionNoIn($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ConditionalExpressionNoIn($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AssignmentExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing AssignmentExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AssignmentExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 15                            (: '!' :)
         and $state[$p:l1] != 27                            (: '+' :)
         and $state[$p:l1] != 28                            (: '++' :)
         and $state[$p:l1] != 31                            (: '-' :)
         and $state[$p:l1] != 32                            (: '--' :)
         and $state[$p:l1] != 63                            (: 'delete' :)
         and $state[$p:l1] != 80                            (: 'typeof' :)
         and $state[$p:l1] != 82                            (: 'void' :)
         and $state[$p:l1] != 90) then                      (: '~' :)
      let $state := p:memoized($state, 8)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-LeftHandSideExpression($input, $state)
          let $state := p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpressionNoIn($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 8)
            else
              p:memoize($backtrack, $state, -2, 8)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:try-LeftHandSideExpression($input, $state)
      let $state := p:try-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpressionNoIn($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ConditionalExpressionNoIn($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consume(30, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpressionNoIn($input, $state)
      return p:parse-ExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExpressionNoIn-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(30, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpressionNoIn($input, $state)
      return p:try-ExpressionNoIn-1($input, $state)
};

(:~
 : Parse ExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AssignmentExpressionNoIn($input, $state)
  let $state := p:parse-ExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing ExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AssignmentExpressionNoIn($input, $state)
  let $state := p:try-ExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse IterationStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IterationStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: 'for' :)
      let $state := p:memoized($state, 7)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(67, $input, $state)      (: 'for' :)
          let $state := p:lookahead1W(1, $input, $state)    (: WhiteSpace | Comment | '(' :)
          let $state := p:consumeT(23, $input, $state)      (: '(' :)
          let $state := p:lookahead1W(24, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 38) then              (: ';' :)
              let $state := p:try-ExpressionNoIn($input, $state)
              return $state
            else
              $state
          let $state := p:consumeT(38, $input, $state)      (: ';' :)
          let $state := p:lookahead1W(24, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 38) then              (: ';' :)
              let $state := p:try-Expression($input, $state)
              return $state
            else
              $state
          let $state := p:consumeT(38, $input, $state)      (: ';' :)
          let $state := p:lookahead1W(23, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 24) then              (: ')' :)
              let $state := p:try-Expression($input, $state)
              return $state
            else
              $state
          let $state := p:consumeT(24, $input, $state)      (: ')' :)
          let $state := p:lookahead1W(28, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
          let $state := p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -3, 7)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:consumeT(67, $input, $state)  (: 'for' :)
              let $state := p:lookahead1W(1, $input, $state) (: WhiteSpace | Comment | '(' :)
              let $state := p:consumeT(23, $input, $state)  (: '(' :)
              let $state := p:lookahead1W(4, $input, $state) (: WhiteSpace | Comment | 'var' :)
              let $state := p:consumeT(81, $input, $state)  (: 'var' :)
              let $state := p:lookahead1W(0, $input, $state) (: Identifier | WhiteSpace | Comment :)
              let $state := p:try-VariableDeclarationListNoIn($input, $state)
              let $state := p:consumeT(38, $input, $state)  (: ';' :)
              let $state := p:lookahead1W(24, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral |
                                                                 OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                 '(' | '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                                 'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                                 '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] != 38) then          (: ';' :)
                  let $state := p:try-Expression($input, $state)
                  return $state
                else
                  $state
              let $state := p:consumeT(38, $input, $state)  (: ';' :)
              let $state := p:lookahead1W(23, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral |
                                                                 OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                 '(' | ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                                 'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                                 '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] != 24) then          (: ')' :)
                  let $state := p:try-Expression($input, $state)
                  return $state
                else
                  $state
              let $state := p:consumeT(24, $input, $state)  (: ')' :)
              let $state := p:lookahead1W(28, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral |
                                                                 OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                 '(' | '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                                 'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                                 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                                 'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                                 'while' | 'with' | '{' | '~' :)
              let $state := p:try-Statement($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -4, 7)
                else
                  let $state := p:restore($backtrack, $state)
                  let $state := p:consumeT(67, $input, $state) (: 'for' :)
                  let $state := p:lookahead1W(1, $input, $state) (: WhiteSpace | Comment | '(' :)
                  let $state := p:consumeT(23, $input, $state) (: '(' :)
                  let $state := p:lookahead1W(21, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral |
                                                                     OctalIntegerLiteral | WhiteSpace | Comment | '(' |
                                                                     '[' | 'function' | 'new' | 'this' | '{' :)
                  let $state := p:try-LeftHandSideExpression($input, $state)
                  let $state := p:consumeT(71, $input, $state) (: 'in' :)
                  let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral |
                                                                     OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                     '(' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                                     'function' | 'new' | 'this' | 'typeof' | 'void' |
                                                                     '{' | '~' :)
                  let $state := p:try-Expression($input, $state)
                  let $state := p:consumeT(24, $input, $state) (: ')' :)
                  let $state := p:lookahead1W(28, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral |
                                                                     OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                     '(' | '+' | '++' | '-' | '--' | ';' | '[' |
                                                                     'break' | 'continue' | 'debugger' | 'delete' |
                                                                     'do' | 'for' | 'function' | 'if' | 'new' |
                                                                     'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                                     'typeof' | 'var' | 'void' | 'while' | 'with' |
                                                                     '{' | '~' :)
                  let $state := p:try-Statement($input, $state)
                  return
                    if (not($state[$p:error])) then
                      p:memoize($backtrack, $state, -5, 7)
                    else
                      p:memoize($backtrack, $state, -6, 7)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: 'do' :)
      let $state := p:consume(64, $input, $state)           (: 'do' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      let $state := p:lookahead1W(5, $input, $state)        (: WhiteSpace | Comment | 'while' :)
      let $state := p:consume(83, $input, $state)           (: 'while' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consume(23, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:consume(24, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(15, $input, $state)       (: END | EOF | WhiteSpace | Comment | ';' | '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Semicolon($input, $state)
      return $state
    else if ($state[$p:lk] = -3) then
      let $state := p:consume(67, $input, $state)           (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consume(23, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 38) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ExpressionNoIn($input, $state)
          return $state
        else
          $state
      let $state := p:consume(38, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 38) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consume(38, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(23, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 24) then                  (: ')' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consume(24, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -4) then
      let $state := p:consume(67, $input, $state)           (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consume(23, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(4, $input, $state)        (: WhiteSpace | Comment | 'var' :)
      let $state := p:consume(81, $input, $state)           (: 'var' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VariableDeclarationListNoIn($input, $state)
      let $state := p:consume(38, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 38) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consume(38, $input, $state)           (: ';' :)
      let $state := p:lookahead1W(23, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 24) then                  (: ')' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consume(24, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -5) then
      let $state := p:consume(67, $input, $state)           (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consume(23, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '(' | '[' |
                                                               'function' | 'new' | 'this' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LeftHandSideExpression($input, $state)
      let $state := p:consume(71, $input, $state)           (: 'in' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:consume(24, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state := p:consume(67, $input, $state)           (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consume(23, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(4, $input, $state)        (: WhiteSpace | Comment | 'var' :)
      let $state := p:consume(81, $input, $state)           (: 'var' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VariableDeclarationNoIn($input, $state)
      let $state := p:consume(71, $input, $state)           (: 'in' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:consume(24, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(83, $input, $state)           (: 'while' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consume(23, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:consume(24, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IterationStatement", $count, $begin, $end)
};

(:~
 : Try parsing IterationStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IterationStatement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: 'for' :)
      let $state := p:memoized($state, 7)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(67, $input, $state)      (: 'for' :)
          let $state := p:lookahead1W(1, $input, $state)    (: WhiteSpace | Comment | '(' :)
          let $state := p:consumeT(23, $input, $state)      (: '(' :)
          let $state := p:lookahead1W(24, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 38) then              (: ';' :)
              let $state := p:try-ExpressionNoIn($input, $state)
              return $state
            else
              $state
          let $state := p:consumeT(38, $input, $state)      (: ';' :)
          let $state := p:lookahead1W(24, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 38) then              (: ';' :)
              let $state := p:try-Expression($input, $state)
              return $state
            else
              $state
          let $state := p:consumeT(38, $input, $state)      (: ';' :)
          let $state := p:lookahead1W(23, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 24) then              (: ')' :)
              let $state := p:try-Expression($input, $state)
              return $state
            else
              $state
          let $state := p:consumeT(24, $input, $state)      (: ')' :)
          let $state := p:lookahead1W(28, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
          let $state := p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -3, 7)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:consumeT(67, $input, $state)  (: 'for' :)
              let $state := p:lookahead1W(1, $input, $state) (: WhiteSpace | Comment | '(' :)
              let $state := p:consumeT(23, $input, $state)  (: '(' :)
              let $state := p:lookahead1W(4, $input, $state) (: WhiteSpace | Comment | 'var' :)
              let $state := p:consumeT(81, $input, $state)  (: 'var' :)
              let $state := p:lookahead1W(0, $input, $state) (: Identifier | WhiteSpace | Comment :)
              let $state := p:try-VariableDeclarationListNoIn($input, $state)
              let $state := p:consumeT(38, $input, $state)  (: ';' :)
              let $state := p:lookahead1W(24, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral |
                                                                 OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                 '(' | '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                                 'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                                 '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] != 38) then          (: ';' :)
                  let $state := p:try-Expression($input, $state)
                  return $state
                else
                  $state
              let $state := p:consumeT(38, $input, $state)  (: ';' :)
              let $state := p:lookahead1W(23, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral |
                                                                 OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                 '(' | ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                                 'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                                 '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] != 24) then          (: ')' :)
                  let $state := p:try-Expression($input, $state)
                  return $state
                else
                  $state
              let $state := p:consumeT(24, $input, $state)  (: ')' :)
              let $state := p:lookahead1W(28, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral |
                                                                 OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                 '(' | '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                                 'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                                 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                                 'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                                 'while' | 'with' | '{' | '~' :)
              let $state := p:try-Statement($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -4, 7)
                else
                  let $state := p:restore($backtrack, $state)
                  let $state := p:consumeT(67, $input, $state) (: 'for' :)
                  let $state := p:lookahead1W(1, $input, $state) (: WhiteSpace | Comment | '(' :)
                  let $state := p:consumeT(23, $input, $state) (: '(' :)
                  let $state := p:lookahead1W(21, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral |
                                                                     OctalIntegerLiteral | WhiteSpace | Comment | '(' |
                                                                     '[' | 'function' | 'new' | 'this' | '{' :)
                  let $state := p:try-LeftHandSideExpression($input, $state)
                  let $state := p:consumeT(71, $input, $state) (: 'in' :)
                  let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral |
                                                                     OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                     '(' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                                     'function' | 'new' | 'this' | 'typeof' | 'void' |
                                                                     '{' | '~' :)
                  let $state := p:try-Expression($input, $state)
                  let $state := p:consumeT(24, $input, $state) (: ')' :)
                  let $state := p:lookahead1W(28, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral |
                                                                     OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                     '(' | '+' | '++' | '-' | '--' | ';' | '[' |
                                                                     'break' | 'continue' | 'debugger' | 'delete' |
                                                                     'do' | 'for' | 'function' | 'if' | 'new' |
                                                                     'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                                     'typeof' | 'var' | 'void' | 'while' | 'with' |
                                                                     '{' | '~' :)
                  let $state := p:try-Statement($input, $state)
                  return
                    if (not($state[$p:error])) then
                      p:memoize($backtrack, $state, -5, 7)
                    else
                      p:memoize($backtrack, $state, -6, 7)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: 'do' :)
      let $state := p:consumeT(64, $input, $state)          (: 'do' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      let $state := p:lookahead1W(5, $input, $state)        (: WhiteSpace | Comment | 'while' :)
      let $state := p:consumeT(83, $input, $state)          (: 'while' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consumeT(23, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:consumeT(24, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(15, $input, $state)       (: END | EOF | WhiteSpace | Comment | ';' | '}' :)
      let $state := p:try-Semicolon($input, $state)
      return $state
    else if ($state[$p:lk] = -3) then
      let $state := p:consumeT(67, $input, $state)          (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consumeT(23, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 38) then                  (: ';' :)
          let $state := p:try-ExpressionNoIn($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(38, $input, $state)          (: ';' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 38) then                  (: ';' :)
          let $state := p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(38, $input, $state)          (: ';' :)
      let $state := p:lookahead1W(23, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 24) then                  (: ')' :)
          let $state := p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(24, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -4) then
      let $state := p:consumeT(67, $input, $state)          (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consumeT(23, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(4, $input, $state)        (: WhiteSpace | Comment | 'var' :)
      let $state := p:consumeT(81, $input, $state)          (: 'var' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-VariableDeclarationListNoIn($input, $state)
      let $state := p:consumeT(38, $input, $state)          (: ';' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 38) then                  (: ';' :)
          let $state := p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(38, $input, $state)          (: ';' :)
      let $state := p:lookahead1W(23, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 24) then                  (: ')' :)
          let $state := p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:consumeT(24, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -5) then
      let $state := p:consumeT(67, $input, $state)          (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consumeT(23, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '(' | '[' |
                                                               'function' | 'new' | 'this' | '{' :)
      let $state := p:try-LeftHandSideExpression($input, $state)
      let $state := p:consumeT(71, $input, $state)          (: 'in' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:consumeT(24, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state := p:consumeT(67, $input, $state)          (: 'for' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consumeT(23, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(4, $input, $state)        (: WhiteSpace | Comment | 'var' :)
      let $state := p:consumeT(81, $input, $state)          (: 'var' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-VariableDeclarationNoIn($input, $state)
      let $state := p:consumeT(71, $input, $state)          (: 'in' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:consumeT(24, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consumeT(83, $input, $state)          (: 'while' :)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consumeT(23, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:consumeT(24, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
  return $state
};

(:~
 : Parse IfStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(70, $input, $state)               (: 'if' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consume(23, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:consume(24, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(28, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Statement($input, $state)
  let $state := p:lookahead1W(34, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'default' | 'delete' | 'do' |
                                                               'else' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: 'else' :)
      let $state := p:memoized($state, 6)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(65, $input, $state)      (: 'else' :)
          let $state := p:lookahead1W(28, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
          let $state := p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 6)
            else
              p:memoize($backtrack, $state, -2, 6)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(65, $input, $state)           (: 'else' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IfStatement", $count, $begin, $end)
};

(:~
 : Try parsing IfStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IfStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(70, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consumeT(23, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:try-Expression($input, $state)
  let $state := p:consumeT(24, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(28, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
  let $state := p:try-Statement($input, $state)
  let $state := p:lookahead1W(34, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'default' | 'delete' | 'do' |
                                                               'else' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: 'else' :)
      let $state := p:memoized($state, 6)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consumeT(65, $input, $state)      (: 'else' :)
          let $state := p:lookahead1W(28, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
          let $state := p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 6)
            else
              p:memoize($backtrack, $state, -2, 6)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consumeT(65, $input, $state)          (: 'else' :)
      let $state := p:lookahead1W(28, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ExpressionStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExpressionStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expression($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExpressionStatement", $count, $begin, $end)
};

(:~
 : Try parsing ExpressionStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExpressionStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Expression($input, $state)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse EmptyStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(38, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyStatement", $count, $begin, $end)
};

(:~
 : Try parsing EmptyStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EmptyStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(38, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse Semicolon.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Semicolon($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 89                                 (: '}' :)
     or $state[$p:l1] eq 3                                  (: EOF :)
     or $state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then   (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state := p:consume(38, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Semicolon", $count, $begin, $end)
};

(:~
 : Try parsing Semicolon.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Semicolon($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 89                                 (: '}' :)
     or $state[$p:l1] eq 3                                  (: EOF :)
     or $state[$p:l1] ne 38 and $state[$p:l1] ge 0 and p:follows-line-terminator($input, $state)) then   (: ';' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state := p:consumeT(38, $input, $state)              (: ';' :)
  return $state
};

(:~
 : Parse PostfixExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LeftHandSideExpression($input, $state)
  let $state :=
    if ($state[$p:l1] = (28, 32) and p:follows-line-terminator($input, $state)) then (: '++' | '--' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28                             (: '++' :)
          or $state[$p:l1] = 32) then                       (: '--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: '++' :)
          let $state := p:consume(28, $input, $state)       (: '++' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(32, $input, $state)       (: '--' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PostfixExpression", $count, $begin, $end)
};

(:~
 : Try parsing PostfixExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PostfixExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LeftHandSideExpression($input, $state)
  let $state :=
    if ($state[$p:l1] = (28, 32) and p:follows-line-terminator($input, $state)) then (: '++' | '--' :)
    (
      subsequence($state, 1, $p:l1 - 1),
      38,                                                   (: ';' :)
      $state[$p:b1],
      $state[$p:b1],
      subsequence($state, $p:e1 + 1)
    )
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28                             (: '++' :)
          or $state[$p:l1] = 32) then                       (: '--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 28) then                   (: '++' :)
          let $state := p:consumeT(28, $input, $state)      (: '++' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consumeT(32, $input, $state)      (: '--' :)
          return $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse UnaryExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: 'delete' :)
      let $state := p:consume(63, $input, $state)           (: 'delete' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'void' :)
      let $state := p:consume(82, $input, $state)           (: 'void' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'typeof' :)
      let $state := p:consume(80, $input, $state)           (: 'typeof' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 28) then                       (: '++' :)
      let $state := p:consume(28, $input, $state)           (: '++' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 32) then                       (: '--' :)
      let $state := p:consume(32, $input, $state)           (: '--' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '+' :)
      let $state := p:consume(27, $input, $state)           (: '+' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 31) then                       (: '-' :)
      let $state := p:consume(31, $input, $state)           (: '-' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 90) then                       (: '~' :)
      let $state := p:consume(90, $input, $state)           (: '~' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 15) then                       (: '!' :)
      let $state := p:consume(15, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PostfixExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpression", $count, $begin, $end)
};

(:~
 : Try parsing UnaryExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: 'delete' :)
      let $state := p:consumeT(63, $input, $state)          (: 'delete' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'void' :)
      let $state := p:consumeT(82, $input, $state)          (: 'void' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'typeof' :)
      let $state := p:consumeT(80, $input, $state)          (: 'typeof' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 28) then                       (: '++' :)
      let $state := p:consumeT(28, $input, $state)          (: '++' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 32) then                       (: '--' :)
      let $state := p:consumeT(32, $input, $state)          (: '--' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '+' :)
      let $state := p:consumeT(27, $input, $state)          (: '+' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 31) then                       (: '-' :)
      let $state := p:consumeT(31, $input, $state)          (: '-' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 90) then                       (: '~' :)
      let $state := p:consumeT(90, $input, $state)          (: '~' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 15) then                       (: '!' :)
      let $state := p:consumeT(15, $input, $state)          (: '!' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-PostfixExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(27, $input, $state)         (: END | EOF | WhiteSpace | Comment | '!=' | '!==' | '%' |
                                                               '&' | '&&' | ')' | '*' | '+' | ',' | '-' | '/' | ':' |
                                                               ';' | '<' | '<<' | '<=' | '==' | '===' | '>' | '>=' |
                                                               '>>' | '>>>' | '?' | ']' | '^' | 'in' | 'instanceof' |
                                                               '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 18                               (: '%' :)
      and $state[$p:l1] != 25                               (: '*' :)
      and $state[$p:l1] != 35) then                         (: '/' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 25) then                 (: '*' :)
            let $state := p:consume(25, $input, $state)     (: '*' :)
            return $state
          else if ($state[$p:l1] = 35) then                 (: '/' :)
            let $state := p:consume(35, $input, $state)     (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consume(18, $input, $state)     (: '%' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-UnaryExpression($input, $state)
        return p:parse-MultiplicativeExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MultiplicativeExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MultiplicativeExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(27, $input, $state)         (: END | EOF | WhiteSpace | Comment | '!=' | '!==' | '%' |
                                                               '&' | '&&' | ')' | '*' | '+' | ',' | '-' | '/' | ':' |
                                                               ';' | '<' | '<<' | '<=' | '==' | '===' | '>' | '>=' |
                                                               '>>' | '>>>' | '?' | ']' | '^' | 'in' | 'instanceof' |
                                                               '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 18                               (: '%' :)
      and $state[$p:l1] != 25                               (: '*' :)
      and $state[$p:l1] != 35) then                         (: '/' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 25) then                 (: '*' :)
            let $state := p:consumeT(25, $input, $state)    (: '*' :)
            return $state
          else if ($state[$p:l1] = 35) then                 (: '/' :)
            let $state := p:consumeT(35, $input, $state)    (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consumeT(18, $input, $state)    (: '%' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
        let $state := p:try-UnaryExpression($input, $state)
        return p:try-MultiplicativeExpression-1($input, $state)
};

(:~
 : Parse MultiplicativeExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpression($input, $state)
  let $state := p:parse-MultiplicativeExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpression", $count, $begin, $end)
};

(:~
 : Try parsing MultiplicativeExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MultiplicativeExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnaryExpression($input, $state)
  let $state := p:try-MultiplicativeExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27                                 (: '+' :)
    and $state[$p:l1] != 31) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 27) then                   (: '+' :)
          let $state := p:consume(27, $input, $state)       (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(31, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MultiplicativeExpression($input, $state)
      return p:parse-AdditiveExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AdditiveExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AdditiveExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27                                 (: '+' :)
    and $state[$p:l1] != 31) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 27) then                   (: '+' :)
          let $state := p:consumeT(27, $input, $state)      (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consumeT(31, $input, $state)      (: '-' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-MultiplicativeExpression($input, $state)
      return p:try-AdditiveExpression-1($input, $state)
};

(:~
 : Parse AdditiveExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MultiplicativeExpression($input, $state)
  let $state := p:parse-AdditiveExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpression", $count, $begin, $end)
};

(:~
 : Try parsing AdditiveExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AdditiveExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-MultiplicativeExpression($input, $state)
  let $state := p:try-AdditiveExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ShiftExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ShiftExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40                                 (: '<<' :)
    and $state[$p:l1] != 48                                 (: '>>' :)
    and $state[$p:l1] != 50) then                           (: '>>>' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: '<<' :)
          let $state := p:consume(40, $input, $state)       (: '<<' :)
          return $state
        else if ($state[$p:l1] = 48) then                   (: '>>' :)
          let $state := p:consume(48, $input, $state)       (: '>>' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(50, $input, $state)       (: '>>>' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpression($input, $state)
      return p:parse-ShiftExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ShiftExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ShiftExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40                                 (: '<<' :)
    and $state[$p:l1] != 48                                 (: '>>' :)
    and $state[$p:l1] != 50) then                           (: '>>>' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: '<<' :)
          let $state := p:consumeT(40, $input, $state)      (: '<<' :)
          return $state
        else if ($state[$p:l1] = 48) then                   (: '>>' :)
          let $state := p:consumeT(48, $input, $state)      (: '>>' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consumeT(50, $input, $state)      (: '>>>' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-AdditiveExpression($input, $state)
      return p:try-ShiftExpression-1($input, $state)
};

(:~
 : Parse ShiftExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ShiftExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AdditiveExpression($input, $state)
  let $state := p:parse-ShiftExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ShiftExpression", $count, $begin, $end)
};

(:~
 : Try parsing ShiftExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ShiftExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AdditiveExpression($input, $state)
  let $state := p:try-ShiftExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production RelationalExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelationalExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39                                 (: '<' :)
    and $state[$p:l1] != 42                                 (: '<=' :)
    and $state[$p:l1] != 46                                 (: '>' :)
    and $state[$p:l1] != 47                                 (: '>=' :)
    and $state[$p:l1] != 71                                 (: 'in' :)
    and $state[$p:l1] != 72) then                           (: 'instanceof' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: '<' :)
          let $state := p:consume(39, $input, $state)       (: '<' :)
          return $state
        else if ($state[$p:l1] = 46) then                   (: '>' :)
          let $state := p:consume(46, $input, $state)       (: '>' :)
          return $state
        else if ($state[$p:l1] = 42) then                   (: '<=' :)
          let $state := p:consume(42, $input, $state)       (: '<=' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: '>=' :)
          let $state := p:consume(47, $input, $state)       (: '>=' :)
          return $state
        else if ($state[$p:l1] = 72) then                   (: 'instanceof' :)
          let $state := p:consume(72, $input, $state)       (: 'instanceof' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(71, $input, $state)       (: 'in' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ShiftExpression($input, $state)
      return p:parse-RelationalExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production RelationalExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelationalExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39                                 (: '<' :)
    and $state[$p:l1] != 42                                 (: '<=' :)
    and $state[$p:l1] != 46                                 (: '>' :)
    and $state[$p:l1] != 47                                 (: '>=' :)
    and $state[$p:l1] != 71                                 (: 'in' :)
    and $state[$p:l1] != 72) then                           (: 'instanceof' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: '<' :)
          let $state := p:consumeT(39, $input, $state)      (: '<' :)
          return $state
        else if ($state[$p:l1] = 46) then                   (: '>' :)
          let $state := p:consumeT(46, $input, $state)      (: '>' :)
          return $state
        else if ($state[$p:l1] = 42) then                   (: '<=' :)
          let $state := p:consumeT(42, $input, $state)      (: '<=' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: '>=' :)
          let $state := p:consumeT(47, $input, $state)      (: '>=' :)
          return $state
        else if ($state[$p:l1] = 72) then                   (: 'instanceof' :)
          let $state := p:consumeT(72, $input, $state)      (: 'instanceof' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consumeT(71, $input, $state)      (: 'in' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-ShiftExpression($input, $state)
      return p:try-RelationalExpression-1($input, $state)
};

(:~
 : Parse RelationalExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelationalExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ShiftExpression($input, $state)
  let $state := p:parse-RelationalExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelationalExpression", $count, $begin, $end)
};

(:~
 : Try parsing RelationalExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelationalExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ShiftExpression($input, $state)
  let $state := p:try-RelationalExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production EqualityExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EqualityExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 16                                 (: '!=' :)
    and $state[$p:l1] != 17                                 (: '!==' :)
    and $state[$p:l1] != 44                                 (: '==' :)
    and $state[$p:l1] != 45) then                           (: '===' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 44) then                   (: '==' :)
          let $state := p:consume(44, $input, $state)       (: '==' :)
          return $state
        else if ($state[$p:l1] = 16) then                   (: '!=' :)
          let $state := p:consume(16, $input, $state)       (: '!=' :)
          return $state
        else if ($state[$p:l1] = 45) then                   (: '===' :)
          let $state := p:consume(45, $input, $state)       (: '===' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(17, $input, $state)       (: '!==' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RelationalExpression($input, $state)
      return p:parse-EqualityExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production EqualityExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EqualityExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 16                                 (: '!=' :)
    and $state[$p:l1] != 17                                 (: '!==' :)
    and $state[$p:l1] != 44                                 (: '==' :)
    and $state[$p:l1] != 45) then                           (: '===' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 44) then                   (: '==' :)
          let $state := p:consumeT(44, $input, $state)      (: '==' :)
          return $state
        else if ($state[$p:l1] = 16) then                   (: '!=' :)
          let $state := p:consumeT(16, $input, $state)      (: '!=' :)
          return $state
        else if ($state[$p:l1] = 45) then                   (: '===' :)
          let $state := p:consumeT(45, $input, $state)      (: '===' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consumeT(17, $input, $state)      (: '!==' :)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-RelationalExpression($input, $state)
      return p:try-EqualityExpression-1($input, $state)
};

(:~
 : Parse EqualityExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EqualityExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-RelationalExpression($input, $state)
  let $state := p:parse-EqualityExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EqualityExpression", $count, $begin, $end)
};

(:~
 : Try parsing EqualityExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EqualityExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-RelationalExpression($input, $state)
  let $state := p:try-EqualityExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseANDExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseANDExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 20) then                           (: '&' :)
      $state
    else
      let $state := p:consume(20, $input, $state)           (: '&' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EqualityExpression($input, $state)
      return p:parse-BitwiseANDExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseANDExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseANDExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 20) then                           (: '&' :)
      $state
    else
      let $state := p:consumeT(20, $input, $state)          (: '&' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-EqualityExpression($input, $state)
      return p:try-BitwiseANDExpression-1($input, $state)
};

(:~
 : Parse BitwiseANDExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseANDExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EqualityExpression($input, $state)
  let $state := p:parse-BitwiseANDExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseANDExpression", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseANDExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseANDExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EqualityExpression($input, $state)
  let $state := p:try-BitwiseANDExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseXORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseXORExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 55) then                           (: '^' :)
      $state
    else
      let $state := p:consume(55, $input, $state)           (: '^' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseANDExpression($input, $state)
      return p:parse-BitwiseXORExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseXORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseXORExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 55) then                           (: '^' :)
      $state
    else
      let $state := p:consumeT(55, $input, $state)          (: '^' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-BitwiseANDExpression($input, $state)
      return p:try-BitwiseXORExpression-1($input, $state)
};

(:~
 : Parse BitwiseXORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseXORExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseANDExpression($input, $state)
  let $state := p:parse-BitwiseXORExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseXORExpression", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseXORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseXORExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseANDExpression($input, $state)
  let $state := p:try-BitwiseXORExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseORExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 86) then                           (: '|' :)
      $state
    else
      let $state := p:consume(86, $input, $state)           (: '|' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseXORExpression($input, $state)
      return p:parse-BitwiseORExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseORExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 86) then                           (: '|' :)
      $state
    else
      let $state := p:consumeT(86, $input, $state)          (: '|' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-BitwiseXORExpression($input, $state)
      return p:try-BitwiseORExpression-1($input, $state)
};

(:~
 : Parse BitwiseORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseORExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseXORExpression($input, $state)
  let $state := p:parse-BitwiseORExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseORExpression", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseORExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseXORExpression($input, $state)
  let $state := p:try-BitwiseORExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LogicalANDExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalANDExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 21) then                           (: '&&' :)
      $state
    else
      let $state := p:consume(21, $input, $state)           (: '&&' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseORExpression($input, $state)
      return p:parse-LogicalANDExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LogicalANDExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalANDExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 21) then                           (: '&&' :)
      $state
    else
      let $state := p:consumeT(21, $input, $state)          (: '&&' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-BitwiseORExpression($input, $state)
      return p:try-LogicalANDExpression-1($input, $state)
};

(:~
 : Parse LogicalANDExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalANDExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseORExpression($input, $state)
  let $state := p:parse-LogicalANDExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LogicalANDExpression", $count, $begin, $end)
};

(:~
 : Try parsing LogicalANDExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalANDExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseORExpression($input, $state)
  let $state := p:try-LogicalANDExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LogicalORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalORExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 88) then                           (: '||' :)
      $state
    else
      let $state := p:consume(88, $input, $state)           (: '||' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LogicalANDExpression($input, $state)
      return p:parse-LogicalORExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LogicalORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalORExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 88) then                           (: '||' :)
      $state
    else
      let $state := p:consumeT(88, $input, $state)          (: '||' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-LogicalANDExpression($input, $state)
      return p:try-LogicalORExpression-1($input, $state)
};

(:~
 : Parse LogicalORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalORExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LogicalANDExpression($input, $state)
  let $state := p:parse-LogicalORExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LogicalORExpression", $count, $begin, $end)
};

(:~
 : Try parsing LogicalORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalORExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LogicalANDExpression($input, $state)
  let $state := p:try-LogicalORExpression-1($input, $state)
  return $state
};

(:~
 : Parse ConditionalExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConditionalExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LogicalORExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: '?' :)
      let $state := p:consume(52, $input, $state)           (: '?' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      let $state := p:consume(37, $input, $state)           (: ':' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConditionalExpression", $count, $begin, $end)
};

(:~
 : Try parsing ConditionalExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ConditionalExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LogicalORExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: '?' :)
      let $state := p:consumeT(52, $input, $state)          (: '?' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      let $state := p:consumeT(37, $input, $state)          (: ':' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse AssignmentOperator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AssignmentOperator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '=' :)
      let $state := p:consume(43, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '*=' :)
      let $state := p:consume(26, $input, $state)           (: '*=' :)
      return $state
    else if ($state[$p:l1] = 36) then                       (: '/=' :)
      let $state := p:consume(36, $input, $state)           (: '/=' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '%=' :)
      let $state := p:consume(19, $input, $state)           (: '%=' :)
      return $state
    else if ($state[$p:l1] = 29) then                       (: '+=' :)
      let $state := p:consume(29, $input, $state)           (: '+=' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: '-=' :)
      let $state := p:consume(33, $input, $state)           (: '-=' :)
      return $state
    else if ($state[$p:l1] = 41) then                       (: '<<=' :)
      let $state := p:consume(41, $input, $state)           (: '<<=' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: '>>=' :)
      let $state := p:consume(49, $input, $state)           (: '>>=' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: '>>>=' :)
      let $state := p:consume(51, $input, $state)           (: '>>>=' :)
      return $state
    else if ($state[$p:l1] = 22) then                       (: '&=' :)
      let $state := p:consume(22, $input, $state)           (: '&=' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: '^=' :)
      let $state := p:consume(56, $input, $state)           (: '^=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(87, $input, $state)           (: '|=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AssignmentOperator", $count, $begin, $end)
};

(:~
 : Try parsing AssignmentOperator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AssignmentOperator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '=' :)
      let $state := p:consumeT(43, $input, $state)          (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '*=' :)
      let $state := p:consumeT(26, $input, $state)          (: '*=' :)
      return $state
    else if ($state[$p:l1] = 36) then                       (: '/=' :)
      let $state := p:consumeT(36, $input, $state)          (: '/=' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '%=' :)
      let $state := p:consumeT(19, $input, $state)          (: '%=' :)
      return $state
    else if ($state[$p:l1] = 29) then                       (: '+=' :)
      let $state := p:consumeT(29, $input, $state)          (: '+=' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: '-=' :)
      let $state := p:consumeT(33, $input, $state)          (: '-=' :)
      return $state
    else if ($state[$p:l1] = 41) then                       (: '<<=' :)
      let $state := p:consumeT(41, $input, $state)          (: '<<=' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: '>>=' :)
      let $state := p:consumeT(49, $input, $state)          (: '>>=' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: '>>>=' :)
      let $state := p:consumeT(51, $input, $state)          (: '>>>=' :)
      return $state
    else if ($state[$p:l1] = 22) then                       (: '&=' :)
      let $state := p:consumeT(22, $input, $state)          (: '&=' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: '^=' :)
      let $state := p:consumeT(56, $input, $state)          (: '^=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consumeT(87, $input, $state)          (: '|=' :)
      return $state
  return $state
};

(:~
 : Parse NewExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NewExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'new' :)
      let $state := p:memoized($state, 3)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-MemberExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 3)
            else
              p:memoize($backtrack, $state, -2, 3)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -2) then
      let $state := p:consume(73, $input, $state)           (: 'new' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '(' | '[' |
                                                               'function' | 'new' | 'this' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NewExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-MemberExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NewExpression", $count, $begin, $end)
};

(:~
 : Try parsing NewExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NewExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'new' :)
      let $state := p:memoized($state, 3)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-MemberExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 3)
            else
              p:memoize($backtrack, $state, -2, 3)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -2) then
      let $state := p:consumeT(73, $input, $state)          (: 'new' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '(' | '[' |
                                                               'function' | 'new' | 'this' | '{' :)
      let $state := p:try-NewExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-MemberExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Arguments (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Arguments-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consume(30, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return p:parse-Arguments-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Arguments (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Arguments-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(30, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return p:try-Arguments-1($input, $state)
};

(:~
 : Parse Arguments.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Arguments($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(23, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 24) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      let $state := p:parse-Arguments-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(24, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Arguments", $count, $begin, $end)
};

(:~
 : Try parsing Arguments.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Arguments($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(23, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               ')' | '+' | '++' | '-' | '--' | '[' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 24) then                      (: ')' :)
      let $state := p:try-AssignmentExpression($input, $state)
      let $state := p:try-Arguments-1($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(24, $input, $state)              (: ')' :)
  return $state
};

(:~
 : Parse FunctionExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(68, $input, $state)               (: 'function' :)
  let $state := p:lookahead1W(8, $input, $state)            (: Identifier | WhiteSpace | Comment | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:consume(4, $input, $state)            (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consume(23, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(9, $input, $state)            (: Identifier | WhiteSpace | Comment | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FormalParameterList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(24, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:consume(85, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FunctionBody($input, $state)
  let $state := p:consume(89, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionExpression", $count, $begin, $end)
};

(:~
 : Try parsing FunctionExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(68, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(8, $input, $state)            (: Identifier | WhiteSpace | Comment | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:consumeT(4, $input, $state)           (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consumeT(23, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(9, $input, $state)            (: Identifier | WhiteSpace | Comment | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:try-FormalParameterList($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(24, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:consumeT(85, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:try-FunctionBody($input, $state)
  let $state := p:consumeT(89, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production Expression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consume(30, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return p:parse-Expression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Expression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Expression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(30, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return p:try-Expression-1($input, $state)
};

(:~
 : Parse Expression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AssignmentExpression($input, $state)
  let $state := p:parse-Expression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expression", $count, $begin, $end)
};

(:~
 : Try parsing Expression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Expression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AssignmentExpression($input, $state)
  let $state := p:try-Expression-1($input, $state)
  return $state
};

(:~
 : Parse PropertySetParameterList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PropertySetParameterList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(4, $input, $state)                (: Identifier :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PropertySetParameterList", $count, $begin, $end)
};

(:~
 : Try parsing PropertySetParameterList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PropertySetParameterList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(4, $input, $state)               (: Identifier :)
  return $state
};

(:~
 : Parse IdentifierName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IdentifierName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: IdentifierName^Token :)
      let $state := p:consume(7, $input, $state)            (: IdentifierName^Token :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'get' :)
      let $state := p:consume(69, $input, $state)           (: 'get' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(75, $input, $state)           (: 'set' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IdentifierName", $count, $begin, $end)
};

(:~
 : Try parsing IdentifierName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IdentifierName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: IdentifierName^Token :)
      let $state := p:consumeT(7, $input, $state)           (: IdentifierName^Token :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'get' :)
      let $state := p:consumeT(69, $input, $state)          (: 'get' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consumeT(75, $input, $state)          (: 'set' :)
      return $state
  return $state
};

(:~
 : Parse PropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PropertyName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7                              (: IdentifierName^Token :)
          or $state[$p:l1] = 69                             (: 'get' :)
          or $state[$p:l1] = 75) then                       (: 'set' :)
      let $state := p:parse-IdentifierName($input, $state)
      return $state
    else if ($state[$p:l1] = 8) then                        (: StringLiteral :)
      let $state := p:consume(8, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PropertyName", $count, $begin, $end)
};

(:~
 : Try parsing PropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PropertyName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7                              (: IdentifierName^Token :)
          or $state[$p:l1] = 69                             (: 'get' :)
          or $state[$p:l1] = 75) then                       (: 'set' :)
      let $state := p:try-IdentifierName($input, $state)
      return $state
    else if ($state[$p:l1] = 8) then                        (: StringLiteral :)
      let $state := p:consumeT(8, $input, $state)           (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse PropertyAssignment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PropertyAssignment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69                             (: 'get' :)
          or $state[$p:l1] = 75) then                       (: 'set' :)
      let $state := p:memoized($state, 5)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-PropertyName($input, $state)
          let $state := p:lookahead1W(3, $input, $state)    (: WhiteSpace | Comment | ':' :)
          let $state := p:consumeT(37, $input, $state)      (: ':' :)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 5)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:consumeT(69, $input, $state)  (: 'get' :)
              let $state := p:lookahead1W(19, $input, $state) (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                                 HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                                 Comment | 'get' | 'set' :)
              let $state := p:try-PropertyName($input, $state)
              let $state := p:lookahead1W(1, $input, $state) (: WhiteSpace | Comment | '(' :)
              let $state := p:consumeT(23, $input, $state)  (: '(' :)
              let $state := p:lookahead1W(2, $input, $state) (: WhiteSpace | Comment | ')' :)
              let $state := p:consumeT(24, $input, $state)  (: ')' :)
              let $state := p:lookahead1W(6, $input, $state) (: WhiteSpace | Comment | '{' :)
              let $state := p:consumeT(85, $input, $state)  (: '{' :)
              let $state := p:lookahead1W(30, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral |
                                                                 OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                 '(' | '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                                 'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                                 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                                 'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                                 'while' | 'with' | '{' | '}' | '~' :)
              let $state := p:try-FunctionBody($input, $state)
              let $state := p:consumeT(89, $input, $state)  (: '}' :)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -2, 5)
                else
                  p:memoize($backtrack, $state, -3, 5)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -2) then
      let $state := p:consume(69, $input, $state)           (: 'get' :)
      let $state := p:lookahead1W(19, $input, $state)       (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PropertyName($input, $state)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consume(23, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | ')' :)
      let $state := p:consume(24, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(6, $input, $state)        (: WhiteSpace | Comment | '{' :)
      let $state := p:consume(85, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(30, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionBody($input, $state)
      let $state := p:consume(89, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:lk] = -3) then
      let $state := p:consume(75, $input, $state)           (: 'set' :)
      let $state := p:lookahead1W(19, $input, $state)       (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PropertyName($input, $state)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consume(23, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PropertySetParameterList($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | ')' :)
      let $state := p:consume(24, $input, $state)           (: ')' :)
      let $state := p:lookahead1W(6, $input, $state)        (: WhiteSpace | Comment | '{' :)
      let $state := p:consume(85, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(30, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionBody($input, $state)
      let $state := p:consume(89, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PropertyName($input, $state)
      let $state := p:lookahead1W(3, $input, $state)        (: WhiteSpace | Comment | ':' :)
      let $state := p:consume(37, $input, $state)           (: ':' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PropertyAssignment", $count, $begin, $end)
};

(:~
 : Try parsing PropertyAssignment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PropertyAssignment($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69                             (: 'get' :)
          or $state[$p:l1] = 75) then                       (: 'set' :)
      let $state := p:memoized($state, 5)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-PropertyName($input, $state)
          let $state := p:lookahead1W(3, $input, $state)    (: WhiteSpace | Comment | ':' :)
          let $state := p:consumeT(37, $input, $state)      (: ':' :)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 5)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:consumeT(69, $input, $state)  (: 'get' :)
              let $state := p:lookahead1W(19, $input, $state) (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                                 HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                                 Comment | 'get' | 'set' :)
              let $state := p:try-PropertyName($input, $state)
              let $state := p:lookahead1W(1, $input, $state) (: WhiteSpace | Comment | '(' :)
              let $state := p:consumeT(23, $input, $state)  (: '(' :)
              let $state := p:lookahead1W(2, $input, $state) (: WhiteSpace | Comment | ')' :)
              let $state := p:consumeT(24, $input, $state)  (: ')' :)
              let $state := p:lookahead1W(6, $input, $state) (: WhiteSpace | Comment | '{' :)
              let $state := p:consumeT(85, $input, $state)  (: '{' :)
              let $state := p:lookahead1W(30, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral |
                                                                 OctalIntegerLiteral | WhiteSpace | Comment | '!' |
                                                                 '(' | '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                                 'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                                 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                                 'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                                 'while' | 'with' | '{' | '}' | '~' :)
              let $state := p:try-FunctionBody($input, $state)
              let $state := p:consumeT(89, $input, $state)  (: '}' :)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -2, 5)
                else
                  p:memoize($backtrack, $state, -3, 5)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -2) then
      let $state := p:consumeT(69, $input, $state)          (: 'get' :)
      let $state := p:lookahead1W(19, $input, $state)       (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' :)
      let $state := p:try-PropertyName($input, $state)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consumeT(23, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | ')' :)
      let $state := p:consumeT(24, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(6, $input, $state)        (: WhiteSpace | Comment | '{' :)
      let $state := p:consumeT(85, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(30, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:try-FunctionBody($input, $state)
      let $state := p:consumeT(89, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:lk] = -3) then
      let $state := p:consumeT(75, $input, $state)          (: 'set' :)
      let $state := p:lookahead1W(19, $input, $state)       (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' :)
      let $state := p:try-PropertyName($input, $state)
      let $state := p:lookahead1W(1, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:consumeT(23, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-PropertySetParameterList($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | ')' :)
      let $state := p:consumeT(24, $input, $state)          (: ')' :)
      let $state := p:lookahead1W(6, $input, $state)        (: WhiteSpace | Comment | '{' :)
      let $state := p:consumeT(85, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(30, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:try-FunctionBody($input, $state)
      let $state := p:consumeT(89, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-PropertyName($input, $state)
      let $state := p:lookahead1W(3, $input, $state)        (: WhiteSpace | Comment | ':' :)
      let $state := p:consumeT(37, $input, $state)          (: ':' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ObjectLiteral (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ObjectLiteral-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(11, $input, $state)         (: WhiteSpace | Comment | ',' | '}' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 30) then                     (: ',' :)
        let $state := p:memoized($state, 4)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(30, $input, $state)    (: ',' :)
            let $state := p:lookahead1W(19, $input, $state) (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' :)
            let $state := p:try-PropertyAssignment($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 4)
              else
                p:memoize($backtrack, $state, -2, 4)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(30, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-PropertyAssignment($input, $state)
        return p:parse-ObjectLiteral-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ObjectLiteral (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ObjectLiteral-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(11, $input, $state)         (: WhiteSpace | Comment | ',' | '}' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 30) then                     (: ',' :)
        let $state := p:memoized($state, 4)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consumeT(30, $input, $state)    (: ',' :)
            let $state := p:lookahead1W(19, $input, $state) (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' :)
            let $state := p:try-PropertyAssignment($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 4)
              else
                p:memoize($backtrack, $state, -2, 4)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consumeT(30, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' :)
        let $state := p:try-PropertyAssignment($input, $state)
        return p:try-ObjectLiteral-1($input, $state)
};

(:~
 : Parse ObjectLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ObjectLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(85, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 89) then                      (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PropertyAssignment($input, $state)
      let $state := p:parse-ObjectLiteral-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 30) then                   (: ',' :)
          let $state := p:consume(30, $input, $state)       (: ',' :)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '}' :)
  let $state := p:consume(89, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ObjectLiteral", $count, $begin, $end)
};

(:~
 : Try parsing ObjectLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ObjectLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(85, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: IdentifierName^Token | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | 'get' | 'set' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 89) then                      (: '}' :)
      let $state := p:try-PropertyAssignment($input, $state)
      let $state := p:try-ObjectLiteral-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 30) then                   (: ',' :)
          let $state := p:consumeT(30, $input, $state)      (: ',' :)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '}' :)
  let $state := p:consumeT(89, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production ArrayLiteral (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrayLiteral-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consume(30, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(25, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | ',' | '-' | '--' | '[' | ']' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 30                        (: ',' :)
             and $state[$p:l1] != 54) then                  (: ']' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-AssignmentExpression($input, $state)
          return $state
        else
          $state
      return p:parse-ArrayLiteral-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArrayLiteral (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArrayLiteral-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(30, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(25, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | ',' | '-' | '--' | '[' | ']' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 30                        (: ',' :)
             and $state[$p:l1] != 54) then                  (: ']' :)
          let $state := p:try-AssignmentExpression($input, $state)
          return $state
        else
          $state
      return p:try-ArrayLiteral-1($input, $state)
};

(:~
 : Parse ArrayLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrayLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(53, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(25, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | ',' | '-' | '--' | '[' | ']' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 30                            (: ',' :)
         and $state[$p:l1] != 54) then                      (: ']' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return $state
    else
      $state
  let $state := p:parse-ArrayLiteral-1($input, $state)
  let $state := p:consume(54, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrayLiteral", $count, $begin, $end)
};

(:~
 : Try parsing ArrayLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArrayLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(53, $input, $state)              (: '[' :)
  let $state := p:lookahead1W(25, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | ',' | '-' | '--' | '[' | ']' | 'delete' |
                                                               'function' | 'new' | 'this' | 'typeof' | 'void' | '{' |
                                                               '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 30                            (: ',' :)
         and $state[$p:l1] != 54) then                      (: ']' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return $state
    else
      $state
  let $state := p:try-ArrayLiteral-1($input, $state)
  let $state := p:consumeT(54, $input, $state)              (: ']' :)
  return $state
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: DecimalLiteral :)
      let $state := p:consume(10, $input, $state)           (: DecimalLiteral :)
      return $state
    else if ($state[$p:l1] = 11) then                       (: HexIntegerLiteral :)
      let $state := p:consume(11, $input, $state)           (: HexIntegerLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(12, $input, $state)           (: OctalIntegerLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Try parsing NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: DecimalLiteral :)
      let $state := p:consumeT(10, $input, $state)          (: DecimalLiteral :)
      return $state
    else if ($state[$p:l1] = 11) then                       (: HexIntegerLiteral :)
      let $state := p:consumeT(11, $input, $state)          (: HexIntegerLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consumeT(12, $input, $state)          (: OctalIntegerLiteral :)
      return $state
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: NullLiteral :)
      let $state := p:consume(5, $input, $state)            (: NullLiteral :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: BooleanLiteral :)
      let $state := p:consume(6, $input, $state)            (: BooleanLiteral :)
      return $state
    else if ($state[$p:l1] = 8) then                        (: StringLiteral :)
      let $state := p:consume(8, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 9) then                        (: RegularExpressionLiteral :)
      let $state := p:consume(9, $input, $state)            (: RegularExpressionLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Try parsing Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: NullLiteral :)
      let $state := p:consumeT(5, $input, $state)           (: NullLiteral :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: BooleanLiteral :)
      let $state := p:consumeT(6, $input, $state)           (: BooleanLiteral :)
      return $state
    else if ($state[$p:l1] = 8) then                        (: StringLiteral :)
      let $state := p:consumeT(8, $input, $state)           (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 9) then                        (: RegularExpressionLiteral :)
      let $state := p:consumeT(9, $input, $state)           (: RegularExpressionLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse PrimaryExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'this' :)
      let $state := p:consume(77, $input, $state)           (: 'this' :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:consume(4, $input, $state)            (: Identifier :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '[' :)
      let $state := p:parse-ArrayLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 85) then                       (: '{' :)
      let $state := p:parse-ObjectLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '(' :)
      let $state := p:consume(23, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:consume(24, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Literal($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpression", $count, $begin, $end)
};

(:~
 : Try parsing PrimaryExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PrimaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'this' :)
      let $state := p:consumeT(77, $input, $state)          (: 'this' :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:consumeT(4, $input, $state)           (: Identifier :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '[' :)
      let $state := p:try-ArrayLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 85) then                       (: '{' :)
      let $state := p:try-ObjectLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '(' :)
      let $state := p:consumeT(23, $input, $state)          (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:consumeT(24, $input, $state)          (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Literal($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production MemberExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MemberExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: END | EOF | WhiteSpace | Comment | '!=' | '!==' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' |
                                                               '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '===' | '>' | '>=' | '>>' | '>>=' | '>>>' |
                                                               '>>>=' | '?' | '[' | ']' | '^' | '^=' | 'in' |
                                                               'instanceof' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '.' :)
      and $state[$p:l1] != 53) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 53) then                 (: '[' :)
            let $state := p:consume(53, $input, $state)     (: '[' :)
            let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Expression($input, $state)
            let $state := p:consume(54, $input, $state)     (: ']' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consume(34, $input, $state)     (: '.' :)
            let $state := p:lookahead1W(13, $input, $state) (: IdentifierName^Token | WhiteSpace | Comment | 'get' |
                                                               'set' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-IdentifierName($input, $state)
            return $state
        return p:parse-MemberExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MemberExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MemberExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: END | EOF | WhiteSpace | Comment | '!=' | '!==' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' |
                                                               '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '===' | '>' | '>=' | '>>' | '>>=' | '>>>' |
                                                               '>>>=' | '?' | '[' | ']' | '^' | '^=' | 'in' |
                                                               'instanceof' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '.' :)
      and $state[$p:l1] != 53) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 53) then                 (: '[' :)
            let $state := p:consumeT(53, $input, $state)    (: '[' :)
            let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
            let $state := p:try-Expression($input, $state)
            let $state := p:consumeT(54, $input, $state)    (: ']' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consumeT(34, $input, $state)    (: '.' :)
            let $state := p:lookahead1W(13, $input, $state) (: IdentifierName^Token | WhiteSpace | Comment | 'get' |
                                                               'set' :)
            let $state := p:try-IdentifierName($input, $state)
            return $state
        return p:try-MemberExpression-1($input, $state)
};

(:~
 : Parse MemberExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MemberExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'function' :)
      let $state := p:parse-FunctionExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'new' :)
      let $state := p:consume(73, $input, $state)           (: 'new' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '(' | '[' |
                                                               'function' | 'new' | 'this' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MemberExpression($input, $state)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Arguments($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PrimaryExpression($input, $state)
      return $state
  let $state := p:parse-MemberExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MemberExpression", $count, $begin, $end)
};

(:~
 : Try parsing MemberExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MemberExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'function' :)
      let $state := p:try-FunctionExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'new' :)
      let $state := p:consumeT(73, $input, $state)          (: 'new' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '(' | '[' |
                                                               'function' | 'new' | 'this' | '{' :)
      let $state := p:try-MemberExpression($input, $state)
      let $state := p:try-Arguments($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-PrimaryExpression($input, $state)
      return $state
  let $state := p:try-MemberExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CallExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CallExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: END | EOF | WhiteSpace | Comment | '!=' | '!==' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' |
                                                               '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '===' | '>' | '>=' | '>>' | '>>=' | '>>>' |
                                                               '>>>=' | '?' | '[' | ']' | '^' | '^=' | 'in' |
                                                               'instanceof' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 23                               (: '(' :)
      and $state[$p:l1] != 34                               (: '.' :)
      and $state[$p:l1] != 53) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 23) then                 (: '(' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Arguments($input, $state)
            return $state
          else if ($state[$p:l1] = 53) then                 (: '[' :)
            let $state := p:consume(53, $input, $state)     (: '[' :)
            let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Expression($input, $state)
            let $state := p:consume(54, $input, $state)     (: ']' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consume(34, $input, $state)     (: '.' :)
            let $state := p:lookahead1W(13, $input, $state) (: IdentifierName^Token | WhiteSpace | Comment | 'get' |
                                                               'set' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-IdentifierName($input, $state)
            return $state
        return p:parse-CallExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CallExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CallExpression-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: END | EOF | WhiteSpace | Comment | '!=' | '!==' | '%' |
                                                               '%=' | '&' | '&&' | '&=' | '(' | ')' | '*' | '*=' | '+' |
                                                               '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '/' |
                                                               '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' |
                                                               '==' | '===' | '>' | '>=' | '>>' | '>>=' | '>>>' |
                                                               '>>>=' | '?' | '[' | ']' | '^' | '^=' | 'in' |
                                                               'instanceof' | '|' | '|=' | '||' | '}' :)
    return
      if ($state[$p:l1] != 23                               (: '(' :)
      and $state[$p:l1] != 34                               (: '.' :)
      and $state[$p:l1] != 53) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 23) then                 (: '(' :)
            let $state := p:try-Arguments($input, $state)
            return $state
          else if ($state[$p:l1] = 53) then                 (: '[' :)
            let $state := p:consumeT(53, $input, $state)    (: '[' :)
            let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
            let $state := p:try-Expression($input, $state)
            let $state := p:consumeT(54, $input, $state)    (: ']' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consumeT(34, $input, $state)    (: '.' :)
            let $state := p:lookahead1W(13, $input, $state) (: IdentifierName^Token | WhiteSpace | Comment | 'get' |
                                                               'set' :)
            let $state := p:try-IdentifierName($input, $state)
            return $state
        return p:try-CallExpression-1($input, $state)
};

(:~
 : Parse CallExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CallExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MemberExpression($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Arguments($input, $state)
  let $state := p:parse-CallExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CallExpression", $count, $begin, $end)
};

(:~
 : Try parsing CallExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CallExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-MemberExpression($input, $state)
  let $state := p:try-Arguments($input, $state)
  let $state := p:try-CallExpression-1($input, $state)
  return $state
};

(:~
 : Parse LeftHandSideExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LeftHandSideExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    let $state := p:memoized($state, 2)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state := p:try-CallExpression($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, -1, 2)
          else
            p:memoize($backtrack, $state, -2, 2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:parse-CallExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NewExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "LeftHandSideExpression", $count, $begin, $end)
};

(:~
 : Try parsing LeftHandSideExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LeftHandSideExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    let $state := p:memoized($state, 2)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state := p:try-CallExpression($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, -1, 2)
          else
            p:memoize($backtrack, $state, -2, 2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:try-CallExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NewExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse AssignmentExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AssignmentExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 15                            (: '!' :)
         and $state[$p:l1] != 27                            (: '+' :)
         and $state[$p:l1] != 28                            (: '++' :)
         and $state[$p:l1] != 31                            (: '-' :)
         and $state[$p:l1] != 32                            (: '--' :)
         and $state[$p:l1] != 63                            (: 'delete' :)
         and $state[$p:l1] != 80                            (: 'typeof' :)
         and $state[$p:l1] != 82                            (: 'void' :)
         and $state[$p:l1] != 90) then                      (: '~' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-LeftHandSideExpression($input, $state)
          let $state := p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 1)
            else
              p:memoize($backtrack, $state, -2, 1)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:parse-LeftHandSideExpression($input, $state)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ConditionalExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AssignmentExpression", $count, $begin, $end)
};

(:~
 : Try parsing AssignmentExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AssignmentExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 15                            (: '!' :)
         and $state[$p:l1] != 27                            (: '+' :)
         and $state[$p:l1] != 28                            (: '++' :)
         and $state[$p:l1] != 31                            (: '-' :)
         and $state[$p:l1] != 32                            (: '--' :)
         and $state[$p:l1] != 63                            (: 'delete' :)
         and $state[$p:l1] != 80                            (: 'typeof' :)
         and $state[$p:l1] != 82                            (: 'void' :)
         and $state[$p:l1] != 90) then                      (: '~' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-LeftHandSideExpression($input, $state)
          let $state := p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 1)
            else
              p:memoize($backtrack, $state, -2, 1)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:try-LeftHandSideExpression($input, $state)
      let $state := p:try-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ConditionalExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse Initialiser.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Initialiser($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(43, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AssignmentExpression($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Initialiser", $count, $begin, $end)
};

(:~
 : Try parsing Initialiser.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Initialiser($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(43, $input, $state)              (: '=' :)
  let $state := p:lookahead1W(22, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | '[' | 'delete' | 'function' |
                                                               'new' | 'this' | 'typeof' | 'void' | '{' | '~' :)
  let $state := p:try-AssignmentExpression($input, $state)
  return $state
};

(:~
 : Parse VariableDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(4, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(18, $input, $state)           (: END | EOF | WhiteSpace | Comment | ',' | ';' | '=' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '=' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Initialiser($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(4, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(18, $input, $state)           (: END | EOF | WhiteSpace | Comment | ',' | ';' | '=' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '=' :)
      let $state := p:try-Initialiser($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production VariableDeclarationList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consume(30, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VariableDeclaration($input, $state)
      return p:parse-VariableDeclarationList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production VariableDeclarationList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 30) then                           (: ',' :)
      $state
    else
      let $state := p:consumeT(30, $input, $state)          (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-VariableDeclaration($input, $state)
      return p:try-VariableDeclarationList-1($input, $state)
};

(:~
 : Parse VariableDeclarationList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-VariableDeclaration($input, $state)
  let $state := p:parse-VariableDeclarationList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclarationList", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclarationList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-VariableDeclaration($input, $state)
  let $state := p:try-VariableDeclarationList-1($input, $state)
  return $state
};

(:~
 : Parse VariableStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(81, $input, $state)               (: 'var' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VariableDeclarationList($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableStatement", $count, $begin, $end)
};

(:~
 : Try parsing VariableStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(81, $input, $state)              (: 'var' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:try-VariableDeclarationList($input, $state)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Block (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Block-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 89) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Statement($input, $state)
        return p:parse-Block-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Block (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Block-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 89) then                          (: '}' :)
        $state
      else
        let $state := p:try-Statement($input, $state)
        return p:try-Block-1($input, $state)
};

(:~
 : Parse Block.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Block($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(85, $input, $state)               (: '{' :)
  let $state := p:parse-Block-1($input, $state)
  let $state := p:consume(89, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Block", $count, $begin, $end)
};

(:~
 : Try parsing Block.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Block($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(85, $input, $state)              (: '{' :)
  let $state := p:try-Block-1($input, $state)
  let $state := p:consumeT(89, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production FunctionBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 89) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SourceElement($input, $state)
        return p:parse-FunctionBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FunctionBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionBody-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 89) then                          (: '}' :)
        $state
      else
        let $state := p:try-SourceElement($input, $state)
        return p:try-FunctionBody-1($input, $state)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionBody-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionBody", $count, $begin, $end)
};

(:~
 : Try parsing FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FunctionBody-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FormalParameterList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FormalParameterList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(10, $input, $state)         (: WhiteSpace | Comment | ')' | ',' :)
    return
      if ($state[$p:l1] != 30) then                         (: ',' :)
        $state
      else
        let $state := p:consume(30, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WhiteSpace | Comment :)
        let $state := p:consume(4, $input, $state)          (: Identifier :)
        return p:parse-FormalParameterList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FormalParameterList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FormalParameterList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(10, $input, $state)         (: WhiteSpace | Comment | ')' | ',' :)
    return
      if ($state[$p:l1] != 30) then                         (: ',' :)
        $state
      else
        let $state := p:consumeT(30, $input, $state)        (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WhiteSpace | Comment :)
        let $state := p:consumeT(4, $input, $state)         (: Identifier :)
        return p:try-FormalParameterList-1($input, $state)
};

(:~
 : Parse FormalParameterList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FormalParameterList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(4, $input, $state)                (: Identifier :)
  let $state := p:parse-FormalParameterList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FormalParameterList", $count, $begin, $end)
};

(:~
 : Try parsing FormalParameterList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FormalParameterList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(4, $input, $state)               (: Identifier :)
  let $state := p:try-FormalParameterList-1($input, $state)
  return $state
};

(:~
 : Parse FunctionDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(68, $input, $state)               (: 'function' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:consume(4, $input, $state)                (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consume(23, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(9, $input, $state)            (: Identifier | WhiteSpace | Comment | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FormalParameterList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(24, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:consume(85, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FunctionBody($input, $state)
  let $state := p:consume(89, $input, $state)               (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing FunctionDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(68, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:consumeT(4, $input, $state)               (: Identifier :)
  let $state := p:lookahead1W(1, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:consumeT(23, $input, $state)              (: '(' :)
  let $state := p:lookahead1W(9, $input, $state)            (: Identifier | WhiteSpace | Comment | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: Identifier :)
      let $state := p:try-FormalParameterList($input, $state)
      return $state
    else
      $state
  let $state := p:consumeT(24, $input, $state)              (: ')' :)
  let $state := p:lookahead1W(6, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:consumeT(85, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:try-FunctionBody($input, $state)
  let $state := p:consumeT(89, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse Statement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Statement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4                              (: Identifier :)
          or $state[$p:l1] = 68                             (: 'function' :)
          or $state[$p:l1] = 85) then                       (: '{' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-FunctionDeclaration($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 0)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:try-Block($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -2, 0)
                else
                  let $state := p:restore($backtrack, $state)
                  let $state := p:try-ExpressionStatement($input, $state)
                  return
                    if (not($state[$p:error])) then
                      p:memoize($backtrack, $state, -5, 0)
                    else
                      p:memoize($backtrack, $state, -12, 0)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:parse-FunctionDeclaration($input, $state)
      return $state
    else if ($state[$p:lk] = -2) then
      let $state := p:parse-Block($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'var' :)
      let $state := p:parse-VariableStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 38) then                       (: ';' :)
      let $state := p:parse-EmptyStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'if' :)
      let $state := p:parse-IfStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 64                             (: 'do' :)
          or $state[$p:l1] = 67                             (: 'for' :)
          or $state[$p:l1] = 83) then                       (: 'while' :)
      let $state := p:parse-IterationStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 60) then                       (: 'continue' :)
      let $state := p:parse-ContinueStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'break' :)
      let $state := p:parse-BreakStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'return' :)
      let $state := p:parse-ReturnStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'with' :)
      let $state := p:parse-WithStatement($input, $state)
      return $state
    else if ($state[$p:lk] = -12) then
      let $state := p:parse-LabelledStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'switch' :)
      let $state := p:parse-SwitchStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'throw' :)
      let $state := p:parse-ThrowStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'try' :)
      let $state := p:parse-TryStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 61) then                       (: 'debugger' :)
      let $state := p:parse-DebuggerStatement($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExpressionStatement($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Statement", $count, $begin, $end)
};

(:~
 : Try parsing Statement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Statement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4                              (: Identifier :)
          or $state[$p:l1] = 68                             (: 'function' :)
          or $state[$p:l1] = 85) then                       (: '{' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-FunctionDeclaration($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 0)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:try-Block($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -2, 0)
                else
                  let $state := p:restore($backtrack, $state)
                  let $state := p:try-ExpressionStatement($input, $state)
                  return
                    if (not($state[$p:error])) then
                      p:memoize($backtrack, $state, -5, 0)
                    else
                      p:memoize($backtrack, $state, -12, 0)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:try-FunctionDeclaration($input, $state)
      return $state
    else if ($state[$p:lk] = -2) then
      let $state := p:try-Block($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'var' :)
      let $state := p:try-VariableStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 38) then                       (: ';' :)
      let $state := p:try-EmptyStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'if' :)
      let $state := p:try-IfStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 64                             (: 'do' :)
          or $state[$p:l1] = 67                             (: 'for' :)
          or $state[$p:l1] = 83) then                       (: 'while' :)
      let $state := p:try-IterationStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 60) then                       (: 'continue' :)
      let $state := p:try-ContinueStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'break' :)
      let $state := p:try-BreakStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'return' :)
      let $state := p:try-ReturnStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'with' :)
      let $state := p:try-WithStatement($input, $state)
      return $state
    else if ($state[$p:lk] = -12) then
      let $state := p:try-LabelledStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'switch' :)
      let $state := p:try-SwitchStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'throw' :)
      let $state := p:try-ThrowStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'try' :)
      let $state := p:try-TryStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 61) then                       (: 'debugger' :)
      let $state := p:try-DebuggerStatement($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ExpressionStatement($input, $state)
      return $state
  return $state
};

(:~
 : Parse SourceElement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SourceElement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Statement($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SourceElement", $count, $begin, $end)
};

(:~
 : Try parsing SourceElement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SourceElement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Statement($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Program (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Program-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(29, $input, $state)         (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral |
                                                               OctalIntegerLiteral | WhiteSpace | Comment | '!' | '(' |
                                                               '+' | '++' | '-' | '--' | ';' | '[' | 'break' |
                                                               'continue' | 'debugger' | 'delete' | 'do' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '~' :)
    return
      if ($state[$p:l1] = 3) then                           (: EOF :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SourceElement($input, $state)
        return p:parse-Program-1($input, $state)
};

(:~
 : Parse Program.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Program($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(31, $input, $state)           (: Shebang | EOF | Identifier | NullLiteral |
                                                               BooleanLiteral | StringLiteral |
                                                               RegularExpressionLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | OctalIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Shebang :)
      let $state := p:consume(2, $input, $state)            (: Shebang :)
      return $state
    else
      $state
  let $state := p:parse-Program-1($input, $state)
  let $state := p:consume(3, $input, $state)                (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Program", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e1 - $p:l1 + 1),
    0,
    $state[$p:e1],
    subsequence($state, $p:e1),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e1 - $p:l1 + 1),
    0,
    $state[$p:e1],
    subsequence($state, $p:e1)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 13                                      (: WhiteSpace :)
     or $match[1] = 14) then                                (: Comment :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      subsequence($state, $p:e1 + 1)
    )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      subsequence($state, $p:e1 + 1)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from parser state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore parser state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo
  {
    let $errors := ($state[$p:memo], $state[$p:error])[.]
    return $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
    $state[$p:memo]/value
  }
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $i for input position $state[$p:e0].
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after successfully trying an alternative.
 : @param $v the id of the successful alternative.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoize($backtrack as item()+,
                           $state as item()+,
                           $v as xs:integer,
                           $i as xs:integer) as item()+
{
  $v,
  subsequence($backtrack, $p:lk + 1, $p:memo - $p:lk - 1),
  element memo
  {
    let $errors := ($state[$p:memo], $state[$p:error])[.]
    return $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
    $state[$p:memo]/value,
    element value {attribute key {$backtrack[$p:e0] * 16 + $i}, $v}
  },
  subsequence($backtrack, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $i
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state the parser state.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoized($state as item()+, $i as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 16 + $i])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Check whether the lookahead token is preceded by a line terminator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:follows-line-terminator($input as xs:string,
                                           $state as item()+
                                          ) as item()+
{
  let $begin := if ($state[$p:e0] eq $state[$p:b1]) then $state[$p:b0] else $state[$p:e0]
  let $preceding-whitespace := substring($input, $begin, $state[$p:b1] - $begin)
  return string-to-codepoints($preceding-whitespace) = (10, 13, 8232, 8233)
};

(:~
 : Parse start symbol Program from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-Program($s as xs:string) as item()*
{
  let $state := p:parse-Program($s, (0, 1, 1, 0, 1, 0, false(), <memo/>))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
